# SW 문제해결 (APS - Algorithm Problem Solving)

## 목차
- [SW 문제해결 (APS - Algorithm Problem Solving)](#sw-문제해결-aps---algorithm-problem-solving)
  - [목차](#목차)
  - [1. 학습 원칙](#1-학습-원칙)
  - [2. 알고리즘 개요](#2-알고리즘-개요)
    - [2.1 알고리즘이란?](#21-알고리즘이란)
    - [2.2 알고리즘 성능 평가](#22-알고리즘-성능-평가)
  - [3. 자료구조](#3-자료구조)
    - [3.1 배열 (Array)](#31-배열-array)
      - [배열의 필요성](#배열의-필요성)
      - [배열 순회 방법](#배열-순회-방법)
      - [부분집합 생성](#부분집합-생성)
    - [3.2 문자열 (String)](#32-문자열-string)
      - [문자열 인코딩](#문자열-인코딩)
      - [문자열 표현 방식](#문자열-표현-방식)
      - [문자열 패턴 매칭 알고리즘](#문자열-패턴-매칭-알고리즘)
    - [3.3 스택 (Stack)](#33-스택-stack)
      - [스택의 응용](#스택의-응용)
      - [관련 개념](#관련-개념)
    - [3.4 큐 (Queue)](#34-큐-queue)
      - [큐의 종류](#큐의-종류)
      - [큐의 응용](#큐의-응용)
    - [3.5 트리 (Tree)](#35-트리-tree)
      - [이진 트리](#이진-트리)
      - [이진 탐색 트리 (BST)](#이진-탐색-트리-bst)
      - [힙 (Heap)](#힙-heap)
  - [4. 정렬과 검색](#4-정렬과-검색)
    - [4.1 정렬 (Sort)](#41-정렬-sort)
    - [4.2 검색 (Search)](#42-검색-search)
  - [5. 분할 정복 (Divide \& Conquer)](#5-분할-정복-divide--conquer)

---

## 1. 학습 원칙
- **기초 자료 구조 이해** 중심으로 학습한다.  
  - 입출력을 제외한 내장 함수 사용을 최소화한다.  
  - 기본 내장 함수의 동작 원리를 직접 이해한다.  
- **AI 활용 방법**  
  - 교과서 대체가 아니라 학습 보조 도구로 활용한다.  
  - 문제 전체 코드를 요청하지 않고 부분적으로 도움을 받는다.  
  - 대화를 통해 문제의 핵심을 스스로 파악하는 습관을 기른다.  

---

## 2. 알고리즘 개요

### 2.1 알고리즘이란?
알고리즘이란 문제를 해결하기 위한 절차나 방법을 의미한다.  
이를 표현하는 방법에는 두 가지가 있다.  

- **의사코드(Pseudocode)**: 코드처럼 보이지만 실제 실행되지는 않는 형태로 알고리즘의 논리를 표현한다.  
- **순서도(Flowchart)**: 도형과 화살표를 사용하여 알고리즘의 흐름을 시각적으로 나타낸다.  

---

### 2.2 알고리즘 성능 평가
좋은 알고리즘의 기준은 다음과 같다.

1. **정확성**: 올바른 결과를 산출해야 한다.  
2. **작업량**: 연산 횟수가 적을수록 좋다.  
3. **메모리 사용량**: 메모리를 효율적으로 사용해야 한다.  
4. **단순성**: 구현이 단순하고 이해하기 쉬워야 한다.  
5. **최적성**: 더 이상 개선할 여지가 없을 정도로 효율적이어야 한다.  

알고리즘의 시간 복잡도는 명령어의 실행 횟수를 기반으로 계산한다. 주로 다음과 같은 표기법을 사용한다.  

- **Big-O**: 최악의 경우 시간 복잡도  
- **Big-Ω**: 최선의 경우 시간 복잡도  
- **Big-Θ**: 평균적인 경우 시간 복잡도  

---

## 3. 자료구조

### 3.1 배열 (Array)
배열은 같은 자료형의 데이터를 일정한 크기로 순차적으로 저장하는 자료구조다.  
하나의 이름으로 여러 데이터를 관리할 수 있어 대량의 데이터를 처리할 때 유용하다.  

#### 배열의 필요성
- 데이터가 많아질수록 관리가 복잡해진다.  
- 배열을 사용하면 인덱스를 통해 원하는 데이터에 바로 접근할 수 있다.  
- 다차원 배열로 확장해 행렬, 지도, 게임 맵 등 다양한 상황에 활용한다.  

#### 배열 순회 방법
배열을 탐색할 때는 다양한 순회 패턴을 사용한다.

1. **행 우선 순회**: 행 단위로 데이터를 차례대로 접근한다.  
2. **열 우선 순회**: 열 단위로 데이터를 차례대로 접근한다.  
3. **지그재그 순회**: 한 행은 왼쪽→오른쪽, 다음 행은 오른쪽→왼쪽 순서로 번갈아 가며 탐색한다.  
4. **델타 탐색**: 상하좌우 또는 대각선 방향으로 인접한 칸을 탐색한다. BFS, DFS 구현 시 자주 사용한다.  

#### 부분집합 생성
- n개의 원소로 만들 수 있는 부분집합의 개수는 **2^n**이다.  
- 비트 연산을 사용하면 효율적으로 부분집합을 생성한다.  
  - `1 << n` → \(2^n\) 계산한다.  
  - `i & (1 << j)` → i의 j번째 비트가 1인지 확인한다.  

---

### 3.2 문자열 (String)

#### 문자열 인코딩
- **ASCII**: 7비트, 128문자 표현한다.  
- **확장 ASCII**: 1바이트, 256문자 표현한다.  
- **유니코드(Unicode)**: 전 세계 문자를 통합 인코딩한다.  
  - UTF-8: 웹에서 주로 사용한다.  
  - UTF-16: Windows, Java에서 사용한다.  
  - UTF-32: Unix 시스템에서 사용한다.  

#### 문자열 표현 방식
- **Length-Controlled**: 문자열 길이를 저장하여 표현한다.  
- **Delimited**: 문자열 끝에 구분자(\0)를 넣어 표현한다.  

#### 문자열 패턴 매칭 알고리즘
1. **고지식한 알고리즘(Brute Force)**: O(MN)  
2. **KMP 알고리즘**: O(M+N)  
3. **Boyer-Moore**: 불일치 문자를 기준으로 점프하여 탐색한다.  

---

### 3.3 스택 (Stack)
스택은 **후입선출(LIFO)** 구조다.  
주요 연산은 push, pop, peek, isEmpty가 있다.  

#### 스택의 응용
- 괄호 검사  
- 재귀 호출  
- 후위 표기법 계산  

#### 관련 개념
- 메모이제이션(Memoization)  
- 동적 계획법(DP)  
- 깊이 우선 탐색(DFS)  
- 백트래킹(Backtracking)  

---

### 3.4 큐 (Queue)
큐는 **선입선출(FIFO)** 구조다.  
주요 연산은 enqueue, dequeue, peek가 있다.  

#### 큐의 종류
- 선형 큐(Linear Queue)  
- 원형 큐(Circular Queue)  
- 연결 큐(Linked Queue)  
- 덱(Deque)  
- 우선순위 큐(Priority Queue)  

#### 큐의 응용
- 너비 우선 탐색(BFS)  
- 버퍼(Buffer) 관리  

---

### 3.5 트리 (Tree)
트리는 계층적 자료구조다. 루트, 노드, 간선, 서브트리, 레벨, 차수 등의 개념을 사용한다.  

#### 이진 트리
- 포화 이진 트리, 완전 이진 트리, 편향 이진 트리 등이 있다.  
- 전위, 중위, 후위 순회를 사용한다.  

#### 이진 탐색 트리 (BST)
- 중위 순회를 사용하면 오름차순 결과가 나온다.  

#### 힙 (Heap)
- **최대 힙**: 부모 ≥ 자식  
- **최소 힙**: 부모 ≤ 자식  

---

## 4. 정렬과 검색

### 4.1 정렬 (Sort)
- **버블 정렬**: O(N²)  
- **선택 정렬**  
- **삽입 정렬**  
- **병합 정렬**: O(N log N), 분할 정복 활용  
- **퀵 정렬**: 평균 O(N log N), 최악 O(N²)  
- **카운팅 정렬**: O(N + K)  

---

### 4.2 검색 (Search)
- **순차 검색**: 정렬 여부에 따라 성능이 달라진다.  
- **이진 검색**: 정렬된 데이터에서만 사용한다.  
- **탐욕 알고리즘(Greedy)**: 매 순간 최적 선택을 한다.  
- **완전 검색(Brute Force)**: 모든 경우를 탐색한다.  

---

## 5. 분할 정복 (Divide & Conquer)
- **Divide**: 문제를 작은 단위로 분할한다.  
- **Conquer**: 각 문제를 해결한다.  
- **Combine**: 결과를 합쳐 최종 해답을 도출한다.  
