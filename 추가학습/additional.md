객체지향(Object-Oriented Programming, OOP)
-
- 객체: 현실 세계의 사물이나 개념을 코드로 표현한 것

class: 전체 구조를 저장할 무언가(설계도)
객체: 실제 데이터를 저장한 무언가

```Python
class Smartphone:
	# 초기화하는 함수
    # 매직 메서드: 언더바 2개로 감싸져 있는 매서드
    # 파이썬 내부에서 특별한 상황에 자동으로 호출된다.
	def __init__(self, model, price):
		self.model = model
		self.price = price

giryunPhone = Smartphone('wide5', '0원')
beomseokPhone = Smartphone('galaxy 21', '100만원')
```
시나리오 -> class로 구현하기(0731 예정)

클래스를 쓰는 이유: 중복된 코드를 줄이기 위해서 -> 효율성!

클래스의 상속
```class ClassOne(ClassZero)```
: ClassZero라는 부모 클래스의 내용을 ClassOne이 상속!

\* 파이썬이 __init__이라는 함수를 호출하도록 만들어 놨기 때문에 가능한 일! 

해싱(hasing): 값을 해시 함수를 통해 정수로 변환 후 버킷에 저장하는 것?
해시 값(정수)이 너무 클 경우 ```return hash_value % bucket_size```를 통해 버킷 내 저장 위치를 조정
다른 값을 해싱했을 때, 이미 값이 저장된 위치의 해시 값이 나왔을 경우 해시 충돌
일반적으로 해시 충돌 발생시 그 다음 위치에 저장한다.
  - 해시 충돌: 다른 key 값이 서로 같은 해시 값을 갖는 경우. 
  - 딕셔너리는 그럴 일 없다! 왜?
버킷이 가득 찼을 경우 bucket size를 2배로 늘린다.

설계를 잘하기 위한 지식보다는
객체지향을 이해하기 위한 지식을 우선 함양하자 -> 남의 코드를 잘 읽어보자

try-except가 일반적으로 if-else보다 느리다. : try-except는 객체를 참조해야 하기 때문.
cf) 파일이 존재하는 지 확인하는 코드 -> if-else문이 더 성능이 떨어진다.

스태틱 메서드: 클래스 안에 작성하지 않고 별개의 함수로 작성해도 기능적으로는 전혀 차이가 없다. 단, 그 메서드가 어느 클래스와 관계가 있는지 명시하기 위해, 즉 개발자의 편의성을 위해 스태틱 메서드로 지정하는 것이다.

다중 상속
서로 다른 초기 인자를 받는 클래스 A, B를 모두 상속받는 클래스 C가 있다고 하자.
super()만으로 두 부모 클래스의 초기 인자를 모두 상속받는 것은 거의 불가능하다.
다중 상속의 경우, super()를 사용하기 보다 직접 부모 클래스들을 자식 클래스에서 명시적으로 호출하는 것을 권장한다.
∵ super()는 mro 순서에 따라 자동으로 클래스를 호출한다, 즉 다중 상속시 예기치 않은 클래스를 호출할 가능성이 있다.