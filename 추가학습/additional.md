객체지향(Object-Oriented Programming, OOP)
-
- 객체: 현실 세계의 사물이나 개념을 코드로 표현한 것

class: 전체 구조를 저장할 무언가(설계도)
객체: 실제 데이터를 저장한 무언가

```Python
class Smartphone:
	# 초기화하는 함수
    # 매직 메서드: 언더바 2개로 감싸져 있는 매서드
    # 파이썬 내부에서 특별한 상황에 자동으로 호출된다.
	def __init__(self, model, price):
		self.model = model
		self.price = price

giryunPhone = Smartphone('wide5', '0원')
beomseokPhone = Smartphone('galaxy 21', '100만원')
```
시나리오 -> class로 구현하기(0731 예정)

클래스를 쓰는 이유: 중복된 코드를 줄이기 위해서 -> 효율성!

클래스의 상속
```class ClassOne(ClassZero)```
: ClassZero라는 부모 클래스의 내용을 ClassOne이 상속!

\* 파이썬이 __init__이라는 함수를 호출하도록 만들어 놨기 때문에 가능한 일! 

해싱(hasing): 값을 해시 함수를 통해 정수로 변환 후 버킷에 저장하는 것?
해시 값(정수)이 너무 클 경우 ```return hash_value % bucket_size```를 통해 버킷 내 저장 위치를 조정
다른 값을 해싱했을 때, 이미 값이 저장된 위치의 해시 값이 나왔을 경우 해시 충돌
일반적으로 해시 충돌 발생시 그 다음 위치에 저장한다.
  - 해시 충돌: 다른 key 값이 서로 같은 해시 값을 갖는 경우. 
  - 딕셔너리는 그럴 일 없다! 왜?
버킷이 가득 찼을 경우 bucket size를 2배로 늘린다.

설계를 잘하기 위한 지식보다는
객체지향을 이해하기 위한 지식을 우선 함양하자 -> 남의 코드를 잘 읽어보자

try-except가 일반적으로 if-else보다 느리다. : try-except는 객체를 참조해야 하기 때문.
cf) 파일이 존재하는 지 확인하는 코드 -> if-else문이 더 성능이 떨어진다.

스태틱 메서드: 클래스 안에 작성하지 않고 별개의 함수로 작성해도 기능적으로는 전혀 차이가 없다. 단, 그 메서드가 어느 클래스와 관계가 있는지 명시하기 위해, 즉 개발자의 편의성을 위해 스태틱 메서드로 지정하는 것이다.

다중 상속
서로 다른 초기 인자를 받는 클래스 A, B를 모두 상속받는 클래스 C가 있다고 하자.
super()만으로 두 부모 클래스의 초기 인자를 모두 상속받는 것은 거의 불가능하다.
다중 상속의 경우, super()를 사용하기 보다 직접 부모 클래스들을 자식 클래스에서 명시적으로 호출하는 것을 권장한다.
∵ super()는 mro 순서에 따라 자동으로 클래스를 호출한다, 즉 다중 상속시 예기치 않은 클래스를 호출할 가능성이 있다.

pypy vs python3

pypy: 메모리는 더 많이, 반복문 등의 로직은 더 빠르게 동작 - 반복문

python3: 메모리는 효율적으로, 로직은 더 느리게 - 재귀호출

가비지 컬렉션?

-pypy
중단점(breakpoint) 설정 가능: 기본적으로 중단점 코드 직전까지 실행 후 , 대기 상태로 전환

디버그 툴 사용법
- 중단점 기준으로 1줄씩 실행
  - f7 - 대기 이후의 코드 한줄씩 실행 / 함수 실행시 함수 코드블럭을 한줄씩 실행
  - f8 - 함수 실행시 함수 전체를 실행
  - f9 - 다음 중단점까지 모두 실행후 대기
- 반복문 내에서 변화하는 변수를 추적할 수도 있다.

연산 시간
- 파이썬은 1초에 3~4천만번의 연산 가능
- 버블정렬은 시간복잡도 O(n^2)
리스트의 길이가 10^4 일경우 연산횟수는 10^8번 = 약 3초

알고리즘의 시간적 성능
- 어느 상황에서 좋은가?
  - 최선: 데이터가 제일 좋게 들어오는 케이스
  - 평균
  - 최악: 데이터가 가장 안좋게 들어오는 케이스

빅오 표기법 O(N) -> O의 N이라 읽는다
n 앞에 붙는 상수는 생략하고 표기한다.
연산횟수가 입력에 관계없이 고정되어 있을 경우 O(1)으로 표기한다.
이진탐색 O(logN)

DAT(Direct Address Table)
- 딕셔너리를 통해 이전 연산의 데이터를 저장함으로써 데이터가 수정, 추가되었을때 효율적으로 결과를 도출하고자 하는 방식.

동적 프로그래밍(Dynamic Programming, DP): 한번한 계산을 반복하지 않기

슬라이딩 윈도우

이진 검색
- 학습단계: binary search, lower bound, upper bound, parametric search


비트 연산자

전치 행렬 만들기
```python
# 2차원 배열 arr에 대해서
for x in range(X):
  for y in range (Y):
    if x < y:
      arr[x][y], arr[y][x] = arr[y][x], arr[x][y]
```