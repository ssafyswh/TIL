B형 특강 8차수
~7주차 - 코드 배틀 35번까지 풀이
이후 문제는 개인적으로 학습하기 / 학습자료 추가 제공
8주차는 모의 시험

문제 읽기 -> 이 알고리즘을 써야겠구나! 가 아닌
문제 읽고 -> 풀어보고(구현 or 시간복잡도 계산해보기) -> 느리네? -> 최적화해야지
이것이 올바른 문제풀이의 흐름이라 보는 것이 옳다!

알고리즘을 배우는 이유는 '이 알고리즘이 없으면 못 푼다' 가 아닌 풀이를 더 빠르게 하기 위함

vector(C++)/arraylist(java)/list(python)
- vector를 잘 안쓰는 이유
직접 구현이 어렵지 않다
내부를 커스텀 할일이 많다
많은 문제에서 사용되지 않는다 -> 연습할 기회가 적다

set/tree-set/set
map/tree-map/
unordered_set, unordered_map/hashset, hashmap/set, dict

배열(vector)
자바, 파이썬은 기본적으로 동적 할당
동적할당 시 별도로 저장하는 배열은 힙메모리에 저장
인덱싱 절대 포기못해 -> 메모리를 연속적인 영역에 배열
add 1번 O(N)
add N번 O(N)

연결리스트(linked-list)
대부분의 자료구조는 배열을 대체하기 위한 것
배열의 어떤 단점을 개선하고 어떤 장점을 포기했는가?

비트마스킹
dp에 활용?: 차원을 늘리기 싫어서 압축(시간복잡도에는 영향x)
상수 최적화에 사용(시간복잡도, 메모리 사용량 절약 가능)
True/False 정보를 담는 배열을 하나의 상수(비트의 모음)로 압축
근본적으로 해싱과 거의 비슷하다

soft-delete: 실제로 데이터를 지우는 것이 아니라, 다른 데이터와 구별되게 삭제되었다는 표시만 남겨두는 것