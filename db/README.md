# DB

데이터베이스: 체계적으로 정리된 데이터의 모음
- 데이터: 저장이나 처리를 위해 변환된 정보
- 역할: CRUD(create, read, updae, delete)
- 관계형 데이터베이스(relational database): 데이터 간에 관계(논리적 연결)가 있는 데이터 항목들의 모음. 서로 관련된 데이터 포인터를 저장하고 이에 대한 액세스를 제공한다.
  - 키워드
    - table(relation): 데이터를 기록하는 곳
    - field(column, attribute): 각 필드에는 고유한 데이터 형식이 지정된다.
    - record(row, tuple): 각 레코드에는 구체적인 데이터 값이 저장된다.
    - database(schema): 테이블의 집합
    - 기본 키(primary key, pk): 각 데이터에 고유한 식별 값을 부여, 레코드의 식별자
    - 외래 키(foreign key, fk): 다른 테이블의 pk를 참조, 테이블 간 관계를 형성
- DBMS(database management system): 데이터베이스를 관리하는 소프트웨어
- RDBMS(relational database management system): 관계형 데이터베이스 관리 소프트웨어
  - SQLite: 경량의 오픈 소스 데이터베이스 관리 시스템. 설치 없이 가볍게 실행이 가능해 모바일 앱이나 소규모 프로그램에 적합하다. 컴퓨터나 모바일 기기에 내장되어 간단하고 효율적인 데이터 저장 및 관리를 제공한다.
SQL(Structure Query Language): 테이블의 형태로 구조화된 관계형 데이터베이스에게 요청을 질의하기 위한 언어.
- SQL syntax
  - SQL 키워드는 대소문자를 구분하지 않는다. (단, 대문자로 작성하는 것을 권장한다.)
  - 각 SQL statements 끝에는 세미콜론으로 구분한다.
- SQL statements: SQL을 구성하는 가장 기본적인 코드블록
  - DDL(data definition language): 데이터의 기본 구조 및 형식 변경(CREATE, DROP, ALTER)
  - DQL(data query language): 데이터 검색(SELECT)
  - DML(data manipulation language): 데이터 조작(INSERT, UPDATE, DELETE)
  - DCL(data control language): 데이터 및 작업에 대한 사용자 권한 제어(COMMIT, ROLLBACK, GRANT, REVOKE)
- DQL syntax
  - SELECT: SELECT 키워드 이후 데이터를 선택하려는 필드를 하나 이상 지정, FROM 키워드 이후 데이터를 선택하려는 테이블의 이름을 지정. '*'를 사용하여 모든 필드를 지정할 수 있다.
  - ORDER BY: FROM clause 뒤에 작성하여 하나 이상의 컬럼을 기준으로 결과를 오름차순(ASC, default) 또는 내림차순(DESC)으로 정렬한다.
  - DISTINCT: SELECT 키워드 바로 뒤에 작성하여 조회 결과에서 중복된 레코드를 제거한다.
  - WHERE: FROM 구문 뒤에 위치하여 비교연산자 및 논리연산자를 사용하는 구문과 함께 조건문과 같은 역할을 한다.
    - 연산자(operator)
      - 비교 연산자(comparison operator)
        - =, >=, <=, !=
        - IS, LIKE, IN
        - BETWEEN ... AND ...
      - 논리 연산자(logical operator)
        - AND(&&)
        - OR(||)
        - NOT(!)
      - wildcard characters
        - '%': 0개 이상의 문자열과 일치하는지 확인
        - '_': 단일문자와 일치하는지 확인
  - LIMIT: 조회하는 최대 레코드 수를 지정
    - LIMIT A, B / LIMIT B OFFSET A
  - GROUP BY: FROM 및 WHERE 절 뒤에 배치하여 필드를 그룹화(요약본을 생성)한다. 집계 함수와 함께 사용된다.
    - 집계 함수(Aggregation Functions): 값에 대한 계산을 수행하고 단일한 값을 반환하는 함수.(SUM, AVG, MAX, MIN, COUNT)
    - HAVING: 집계 항목에 대한 세부 조건을 지정. 주로 GROUP BY와 함께 사용되며 GROUP BY가 없을경우 WHERE 처럼 동작한다.
      - WHERE vs HAVING
        - WHERE
          - 목적: 개별 행에 대한 조건을 지정하여 데이터를 필터링
          - 적용 시점: FROM과 JOIN 등의 단계 이후, GROUP BY 이전에 적용된다.
          - 사용 예: 특정 조건을 만족하는 행 만을 대상으로 집계나 정렬 등의 작업을 수행할 때 사용
        - HAVING
          - 목적: GROUP BY에 의해 그룹화된 결과에 대해 조건을 지정하여 그룹을 필터링
          - 적용 시점: 그룹핑 및 집계 함수 적용 후에 조건을 평가
          - 사용 예: 그룹별 집계 결과에 조건을 걸어 특정 그룹만을 선택할 때 사용
  - SELECT statement 실행 순서: FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY - LIMIT
- DDL syntax
  - CREATE TABLE 
    - 데이터 타입
      - NULL
      - TEXT
      - INTEGER
      - BLOB: 이미지, 동영상, 문서 등의 바이너리 데이터
      - REAL: 부동 소수점
    - 제약 조건(Contraints): 테이블의 필드에 적용되는 규칙 또는 제한사항. 데이터의 무결성을 유지하고 데이터베이스의 일관성을 보장한다.
      - PRIMARY KEY: 해당 필드를 기본 키로 지정(INTEGER 타입만 적용 가능)
      - NOT NULL: 해당 필드에서 NULL값 비허용
      - FOREIGN KEY: 다른 테이블과의 외래 키 관계를 정의
    - AUTOINCREMENT keyword: 필드의 자동 증가를 나타내는 특수한 키워드
      - 주로 PRIMARY KEY 필드에 적용한다.
      - INTEGER PRIMARY KEY AUTOINCREMENT가 작성된 필드는 항상 새로운 레코드에 대해 이전 최대 값보다 큰 값을 할당한다.
      - 삭제된 값은 무시되며 재사용할수 없게 된다.
  - ALTER TABLE(테이블 및 필드 조작)
    - ADD COLUMN: 필드 추가
      - DEFAULT: 디폴트 값 설정 가능
    - RENAME COLUMN: 필드 이름 변경
      - currnent_name TO new_name;
    - DROP COLUMN: 필드 삭제
    - RENAME TO: 테이블 이름 변경
  - DROP TABLE
- DML syntax
  - INSERT
  - UPDATE
    - SET clause 다음에 수정할 필드와 새 값을 지정
    - WHERE clause 에서 수정할 레코드를 지정하는 조건을 작성
    - WHERE clause를 작성하지 않을 경우 모든 레코드를 수정
  - DELETE
    - DELETE FROM ~ WHERE ~
  - JOIN: 들 이상의 테이블에서 데이터를 검색(데이터의 물리적 변환 없음)
    - ON: JOIN할 레코드의 조건을 작성
    - INNER JOIN: 두 테이블에서 값이 일치하는 레코드에 대해서만 결과를 반환
    - LEFT JOIN: 오른쪽 테이블의 일치하는 레코드와 왼쪽 테이블의 모든 레코드를 반환. 매칭되는 레코드가 없을경우 NULL을 표시
- Many to one realtionship
  - 관계(relationship): 데이터베이스 내 여러 테이블 간의 논리적인 연결 관계
    - 1:1(one to one): 한 테이블의 레코드가 다른 테이블의 한 레코드가 연결되어 있음
    - N:1(many to one): 여러 개의 레코드(0개 이상)가 하나의 레코드와 연결됨
    - N:M(many to many): 여러 레코드가 다른 여러 레코드와 상호 연결됨. 보통 중간 테이블을 사용하여 구현한다. 
  - foriegn key field: ForeignKey(to, on_delete): 한 모델이 다른 모델을 참조하는 관계를 설정하는 필드
    - to: 참조하는 모델 class 명(N:1에서 1)
    - on_delete 속성: 외래 키가 참조하는 객체가 사라졌을 때, 외래 키를 가진 객체를 어떻게 처리할 지를 정의하는 설정(데이터 무결성)
      - CASCADE: 참조된 객체가 삭제될 때 이를 참조하는 모든 객체도 삭제되도록 지정
      - PROTECT: 삭제하려는 부모객체에 자식객체가 존재한다면 해당 부모 객체를 삭제하지 못하도록 지정
      - SET_NULL: 부모 객체가 삭제되면, 해당 필드에 값이 NULL이 저장되도록 지정 (단, ForeignKey 설정이 null = True 여야 한다.)
    - 만들어지는 필드는 작성한 foreign key 이름 + _id로 생성된다. (foriegn key이름에 _id를 붙일 필요가 없음 + 외래 키 이름은 단수형으로 생성하기)
    - 외래 키 필드는 bigint 자료형으로 생성된다.(64비트 정수형)
    - 참조: 직접 대상의 정보를 저장하고 필요할 때 활용하는 것
    - 역참조: 나를 참조하는 것을 역으로 조회하는 것
      - 구조: ```article.comment_set.all()```
        - article(모델 인스턴스): models.py에 정의된 모델 클래스로 생성된 실제 데이터. 참조 가능한 필드가 없는 모델 클래스의 인스턴스를 사용해야 한다. (N:1에서의 1에 해당)
        - comment_set(related manager, 역참조 이름): 역참조 시 사용하는 매니저. 이 매니저를 통해 QuerySet API를 사용할 수 있게 된다. 모델 클래스명_set이 기본 값이며 django에서 자동으로 생성해준다.
        - ```all()```(QuerySet API): 데이터를 가져오기 위한 쿼리 집합을 만드는 인터페이스. SQL 쿼리를 직접 사용하지 않고도 db를 사용할 수 있다.
  - 모델 관계 설정
    - 예시: user-article
    - User 모델을 직접 Article에서 import해서 사용하는 것이 아니라 외래 키로 정의한다.
    - User 모델 참조하기
      - settings.AUTH_USER_MODEL
        - settings.py에서 정의된 AUTH_USER_MODEL 설정 값을 가져온다.
        - 반환 값: 'accounts.User'(string)
        - models.py에서 유저 모델을 참조할 경우 사용
      - get_user_model():
        - 현재 settings.py에 정의되어 활성화된 User 모델을 가져온다.
        - 반환 값: User Object
        - models.py를 제외한 다른 모든 위치에서 사용
- View decorator: View 함수의 동작을 수정하거나 추가 기능을 제공하는 데 사용하는 파이썬 데코레이터. 로그인 여부, 권한 검사, http 요청 방식 제한 등을 다룬다.      
  - allowed http methods: view가 허용하는 http 요청 방식을 제한
    - ```require_http_methods["METHOD1", "METHOD2", ...]```: 지정된 http method만 허용
    - ```require_safe()```: GET과 HEAD만 허용
    - ```require_POST()```: POST만 허용
    - 허용되지 않은 method일 경우 405 (method not allowed) 오류를 반환한다.
  - conditional view processing: 클라이언트가 보낸 조건을 확인한 후, 조건에 따른 응답을 처리
  - gzip compression: 서버에서 응답 데이터를 압축해서 전송
- ERD(Entity-Relationship Diagram): 데이터베이스의 구조를 시각적으로 표현하는 도구
  - 구성 요소
    - 엔티티(entity): 데이터베이스에 저장되는 객체나 개념. 데이터베이스에서 주로 테이블로 표현된다.
    - 속성(attribute): 엔티티가 갖는 고유한 데이터 항목. 테이블의 컬럼으로 표현된다.
    - 관계(relationship): 엔티티 간의 연관성. 테이블 간의 연결된 선으로 표현된다.
  - cardinality: 한 엔티티와 다른 엔티티 간의 수적 관계를 나타내는 표현.(one-to-one, many-to-one, many-to-many) 관계를 표현하는 선의 끝부분에 표시되며 일반적으로 숫자나 기호(crow's foot)로 표현된다.
  - 중요성
    - 데이터베이스 설계의 핵심 도구: 엔티티, 속성, 관계를 명확히 정의함으로써 논리적 데이터 구조를 시각적으로 표현하고 복잡한 비즈니스 로직을 단순하고 직관적인 다이어그램을 정리한다. 중복 데이터를 제거하고, 효율적인 저장 구조를 만들 수 있다.
    - 시각적 모델링으로 효과적인 의사소통 지원: 개발자, 기획자, 디자이너 등 다양한 직군이 ERD를 활용해 협업할 수 있다. 요구사항 분석 단계에서 누락된 기능이나 관계를 빠르게 파악 가능하고 비전문가에게도 시스템 구조를 쉽게 설명할 수 있다.
    - 실제 시스템 개발 전 데이터 구조 최적화: 사전에 데이터 흐름과 연관 관계를 명확히 분석해 불필요한 관계나 비효율적인 설계를 방지할 수 있다. 시스템 개발 전에 ERD를 작성함으로써, 이후 db 구축 단계에서 중대한 구조적 오류를 줄이는 데 효과적이고 변경이나 유지보수 시에도 ERD를 기반으로 안정적으로 수정할 수 있다.
- Many-to-many relationship
  - N:1의 한계 상황
    - 환자-의사의 예시: 동일한 환자가 다른 의사에게도 진료받기 위해 새로운 예약 데이터를 만들어야 할때, 동일한 환자 정보를 또 작성하여 저장하게 된다. 데이터의 중복이 발생할 경우, 이후 환자의 정보가 변경되었을 때 모든 예약 정보를 일일이 찾아 고쳐야 하는 문제가 발생하고 실수로 하나라도 누락하게 된다면 데이터의 일관성이 깨지게 된다.
    - 외래 키 컬럼에 '1,2'와 같은 형태로 저장하는 것은 DB 타입 문제로 불가능하다. (제 1 정규형 위반)
    - 제 1 정규형: 테이블의 모든 칸에 더 이상 쪼갤 수 없는 하나의 값만 넣어야 한다.
    - 의사의 정보와 환자의 정보를 모두 외래키로 참조하는 별개의 테이블을 만들면 이와 같은 문제를 해결 가능하다.
  - 중개 모델: 다대다 관계에서 두 모델을 연결하는 역할을 하는, 특별한 기능을 가진 모델
  - ManyToManyField(): M:N 관계 설정 모델 필드
    - 이 필드를 설정하면 django는 자동으로 중간 테이블(중개 모델)을 생성하여 각 모델 간의 관계를 관리한다. (중개하는 클래스를 생성하는 것보다 더 객체 지향적인 표현) 모델 클래스 내부에 필드로 정의하며, 어느 모델에 정의해도 관계는 동일하게 유지된다. ManyToManyField의 필드명은 다대다 관계를 나타내기 위해 복수형으로 작성할 것을 권장한다.
    - 기본 조작 메서드
      - patient(역참조 대상, patient, ManyToManyField 보유) - doctor(참조 대상)로 가정
      - 중개 테이블에 새로운 데이터를 추가
        - ```patient.doctors.add(doctor1)```: 단일 인스턴스 추가
        - ```patient.doctors.add(doctor2, doctor3)```: 복수 인스턴스 한번에 추가
      - 중개 테이블에 있는 데이터를 삭제(인스턴스에는 영향x)
        - ```patient.doctors.remove(doctor1)```: 단일 관계 삭제
        - ```patient.doctors.remove(doctor2, doctor3)```: 복수 관계 한번에 삭제
    - 기본 ManyToManyField의 한계
      - 기본 ManyToManyField로 생성된 중개 테이블은 참조 모델들에 대한 외래 키만을 저장하고 있기 때문에 이 중개 테이블에 다른 추가 정보가 필요할 경우 기본 필드를 그대로 사용할 수 없다.
      - 추가 정보를 저장하기 위해서는 사용자가 직접 중개 테이블을 정의해야 한다. 단, 이 경우 add, remove 메서드를 사용할 수 없다.
      - add, remove 메서드를 그대로 활용하기 위해서는 through 속성을 통해 사용자가 작성한 중개 테이블을 등록해야 한다.
    - ManyToManyField의 대표 arguments
      - 'through' : 중개 테이블에 추가 데이터를 사용해 M:N 관계를 형성하려는 경우 사용한다.
      - 'related_name': 역참조 이름을 변경할 때 사용한다.
      - 'symmetrical': 관계 설정 시 대칭(source와 target이 서로 같은 관계)에 대한 설정을 한다.
  - 프로필 페이지 구현
    - 사용자가 작성한 게시글 목록 (N:1, 역참조)
    - 사용자가 작성한 댓글 목록(N:1, 역참조)
    - 사용자가 좋아요를 누른 게시글 목록(N:M 역참)
  - 팔로우 기능(유저-유저 N:M): 단방향 관계임에 유의
- Fixtures: django 개발 시 데이터베이스 초기화 및 공유를 위해 사용되는 파일 형식
  - 사용 목적
    - 초기 데이터 세팅: 웹 서비스가 처음 시작될 때 필요한 기본 데이터(기본 권한 그룹, 상품 카테고리 등)를 미리 세팅할 수 있다.
    - 테스트 샘플 데이터 준비: 테스트할 때, 항상 동일하고 예측 가능한 데이터 환경을 구축하여 테스트의 신뢰성과 반복 가능성을 높이는 데 활용된다.
    - 협업 시 동일한 데이터 환경 구성: 팀원들이 각자의 개발 환경을 설정할 때, 모두 동일한 초기 데이터나 특정 데이터셋을 쉽게 공유하고 적용함으로써 개발 환경간의 일관성을 유지하고 협업 효율을 높이는 데 도움을 준다.
  - 명령어
    - ```$ python manage.py dumpdata appname.modelname option > filename.json```: 데이터베이스에서 데이터를 내보낸다. 주로 json 파일 형태로 추출하고, 특정 테이블의 데이터만 추출하는 것도 가능하다.
      - appname만 지정: 해당 앱의 모든 데이터를 추출
      - appname.modelname 지정: 특정 모델의 데이터를 추출
      - appname 지정 x: 프로젝트 전체의 모델 데이터를 추출
      - --format 옵션으로 형식 지정 가능(deafult: json)
    - ```$ python manage.py loaddata filepath```: 데이터베이스에 데이터를 불러온다. 내보내기 형태로 저장된 json을 읽어와 데이터베이스에 저장한다.
      - fixture 파일의 기본 경로: app_name/fixtures
      - 파일을 한번에 load할 경우 자동으로 우선순위가 높은 순서로 불러오나, 하나씩 load할 경우 모델 간의 우선순위에 주의할 필요가 있다.
- N+1 Problem: 1개의 쿼리로 데이터를 가져왔더라도 관련 데이터를 추가로 가져오기 위해 추가 쿼리가 N개 더 실행되는 상황. - ORM에서 관련 객체를 반복적으로 접근할 때 과도한 쿼리가 발생
  - django annotate: sql의 group by를 사용하여 각 행 별로 계산된 필드를 추가하고 기존 필드에 새로운 필드를 추가하여 계산된 값을 넣어 반환
  - select-related
  - prefetch-related
   