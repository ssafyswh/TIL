# Python

인터프리터 vs 컴파일러
  - 컴파일러: 전체 코드를 번역한 후 한줄씩 실행
    - 장점: 빠르다
  - 인터프리터: 코드를 한줄씩 번역하며 실행
    - 장점: 디버깅이 편하다. (개발과 테스트가 빠름)
프로그램의 실행 속도 면에서는 컴파일러가 우수, **파이썬**은 인터프리터 언어!

파이썬이 갖는 장점
  - 쉽고 간결한 문법: 읽기 쉽고 쓰기 쉬운 문법을 가지고 있어 쉽게 배우고 활용할 수 있음
  - 커뮤니티의 지원: 세계적인 규모의 풍부한 온라인 포럼 및 커뮤니티 생태계를 형성하고 있음
  - 광범위한 응용 분야: 웹 개발, 데이터 분석, 인공지능, 자동화 스크립트 등 다양한 분야에서 사용함

표현식(expression): 하나의 '값'으로 평가될 수 있는 모든 코드
  - 예시: 3 + 5, x > 10, 5 * 4
값(value): 표현식이 평가된 결과, 더 이상 계산되거나 평가될 수 없는, 프로그램의 가장 기본적인 데이터 조각
  - 예시: 103.14(숫자값), "안녕하세요"(문자열 값), True(불리언 값) 


자료형
-

list: 여러개의 값을 순서대로 저장하는, 변경 가능한(**mutable**) 시퀀스 자료형
- 대괄호 안에 값들을 쉼표로 구분하여 만든다.
- 숫자, 문자열, 혹은 다른 리스트 등 모든 종류의 데이터를 담을 수 있다.
- 값을 추가, 수정, 삭제 등 자유롭게 변경이 가능하다.

```Python
my_list_1 = []
my_list_2 = [1, 'a', 3, 'b', 5]
my_list_3 = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]
```
리스트의 시퀀스 특징
- 리스트는 시퀀스이므로, 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능하다.

```Python
# 인덱싱
print(my_list[1])  # a

# 슬라이싱
print(my_list[2:4])  # [3, 'b']
print(my_list[:3])  # [1, 'a', 3]
print(my_list[3:])  # ['b', 5]
print(my_list[::2])  # [1, 3, 5]
print(my_list[::-1])  # [5, 'b', 3, 'a', 1]

# 길이
print(len(my_list))  # 5
```
- 중첩 리스트(nested list): 다른 리스트를 값으로 가지는 리스트
- 중첩 리스트에 접근하기: 인덱스를 연달아 사용하여 안쪽 리스트의 값에 접근할 수 있다.
```Python
# 중첩된 리스트 접근
my_list = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]
print(len(my_list))  # 5
print(my_list[4][-1])  # !!!
print(my_list[-1][1][0])  # w
```
- 리스트의 가변성: 한번 생성된 리스트는 그 내용을 자유롭게 수정, 추가, 삭제할 수 있다. 문자열이 불변성(immutable)을 갖는 시퀀스인 것과 대조적이다.

```Python
# 리스트는 가변
# 1. 인덱싱으로 값 수정
my_list = [1, 2, 3, 4, 5]
my_list[1] = 'two'
print(my_list)  # [1, 'two', 3, 4, 5]

# 2. 슬라이싱으로 값 수정
my_list = [1, 2, 3, 4, 5]
my_list[2:4] = ['three', 'four']
print(my_list)  # [1, 2, 'three', 'four', 5]
```
- 리스트의 활용법(메서드)
```Python
numbers = []

numbers.append(3) # append: 가장 뒤에 데이터를 추가
numbers.append(2)
numbers.append(1)
numbers.append(5)
print(numbers) # [3, 2, 1, 5]
print(numbers[0]) # 3
print(numbers[-1]) # 5

numbers.pop() # pop(): 맨 뒤의 데이터를 삭제
print(numbers) # [3, 2, 1]
numbers.pop(1) # 해당 인덱스에 위치한 데이터를 삭제
print(numbers) # [3, 1]
```

튜플(tuple): 여러개의 값을 순서대로 저장하는 변경이 불가능한 시퀀스 자료형
- 소괄호 안에 값들을 쉼표로 구분하여 만든다.
- 모든 종류의 데이터를 담을 수 있다.
- 리스트와 거의 모든 면에서 비슷하지만, 한번 만들어지면 절대 수정할 수 없다는 결정적인 차이점을 갖는다.
```Python
# 튜플 표현
my_tuple_1 = ()
my_tuple_2 = (1,) # 단일 요소 튜플의 경우 반드시 후행 쉼표가 와야한다.
my_tuple_3 = (1, 'a', 3, 'b', 5)
my_tuple_4 = 1, 'hello', 3.14, True # 소괄호 없이도 튜플을 만들 수 있다.
```
- 튜플 역시 시퀀스 자료형이므로, 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능하다.
```Python
# 인덱싱
print(my_tuple[1])  # a

# 슬라이싱
print(my_tuple[2:4])  # (3, 'b')
print(my_tuple[:3])  # (1, 'a', 3)
print(my_tuple[3:])  # ('b', 5)
print(my_tuple[::2])  # (1, 3, 5)
print(my_tuple[::-1])  # (5, 'b', 3, 'a', 1)

# 길이
print(len(my_tuple))  # 5
```
- 튜플의 사용처: 튜플의 불변 특성을 사용하여 내부 동작과 안전한 데이터 전달에 사용된다. (다중 할당, 값 교환, 함수 다중 반환 값 등)
- 사용자가 튜플을 직접 사용하는 경우는 거의 없다.

range: 연속된 정수 시퀀스를 생성하는 불변성을 갖는 자료형
- 주로 반복분과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 유용하다.
- 실제로 모든 숫자를 메모리에 저장하는 대신, 시작값, 끝값, 간격이라는 규칙만 기억하여 메모리를 매우 효율적으로 사용한다.
- 주로 반복문과 함께 활용된다.
```python
range(start, stop, step)
```
- range 매개변수별 특징
  - range(stop)
    - 매개 변수가 하나면 stop으로 인식한다.
    - start는 0, step은 1이 디폴트
    - range(5) -> 0, 1, 2, 3, 4
  - range(start, stop)
    - 매개 변수가 두개면 start와 stop으로 인식한다.
    - step은 1이 디폴트
    - range(2, 5) -> 2, 3, 4
  - range(start, stop, step)
    - 모든 매개변수를 직접 지정하는 경우
    - range(2, 10, 2) -> 2, 4, 6, 8

딕셔너리(dict): key - value 쌍으로 이루어진 순서와 중복이 없는(비시퀀스) 변경 가능한 자료형
- 표현법: 중괄호 안에 값들이 쉼표로 구분되어 있다.
  - 값 1개는 키와 값이 쌍으로 이루어져 있다.
    - 키(key): 값을 식별하기 위한 고유한 이름표
      - 고유해야 하기 때문에 중복될 수 없다.
      - 변경 불가능한 자료형만 가능하다. (str, int, float, tuple)
    - 값(value): 키에 해당하는 실제 데이터
    - **※**각 값에는 순서가 존재하지 않는다.
- 값 접근법
  - 키를 사용하여 값을 꺼내올 수 있다.
  - 키에 접근할 때는 대괄호를 사용한다.
```python
my_dict = {'name': '홍길동', 'age': 25}
print(my_dict['name'])  # '홍길동'
print(my_dict['test'])  # KeyError: 'test'
```
- 값 추가 및 변경
```Python
my_dict = {'apple': 12, 'list': [1, 2, 3]}
# 추가
my_dict['banana'] = 50
print(my_dict)  # {'apple': 12, 'list': [1, 2, 3], 'banana': 50}
# 변경
my_dict['apple'] = 100
print(my_dict)  # {'apple': 100, 'list': [1, 2, 3], 'banana': 50}
```
- 키의 존재 유무 검사
```Python
print(di.get(key)) # value를 출력
print(di.get('없는 키')) # None을 출력
```

세트(set): 순서와 중복이 없는 변경 가능한 자료형
- 중괄호 안에 값들을 쉼표로 구분하여 만든다.
- 수학에서의 집합과 동일한 연산 처리가 가능하다.
- ※ 비어있는 딕셔너리와의 혼동을 피하기 위해, 비어있는 세트는 반드시 set() 함수로 만들어야 한다.

세트의 집합 연산: 세트는 수학의 집합 개념을 그대로 가져와, 두 데이터 그룹 간의 관계를 파악하는데 매우 효과적이다.
```Python
my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}

# 합집합
print(my_set_1 | my_set_2)  # {1, 2, 3, 6, 9}

# 차집합
print(my_set_1 - my_set_2)  # {1, 2}

# 교집합
print(my_set_1 & my_set_2)  # {3}

# 대칭차집합
print(my_set_1 ^ my_set_2) # {1, 2, 6, 9}

# 부분집합 확인
print(my_set_1 < my_set_2) # False
```
그 외의 데이터 타입들(other types)
- None: 파이썬에서 값이 없을 표현하는 특별한 데이터 타입. <br>숫자 0이나 빈 문자열과는 다르게 값이 존재하지 않음 또는 아직 정해지지 않음 이라는 상태를 나타내기 위해 사용된다.
- Boolean: 참(True)과 거짓(False) 두가지 값만 갖는 데이터 타입 <br>비교/논리 연산의 평가 결과로 사용되며 주로 조건/반복문과 함께 사용된다.
- Collection: 여러개의 값을 하나로 묶어 관리하는 자료형들을 통칭하는 말(str, list, tuple, range, set, dict)
---
불변과 가변
- 컬렉션 타입은 생성 후 내용을 변경할 수 있는지 없는지에 따라 불변과 가변 두 그룹으로 나뉜다.
  - 불변(immutable): 변경 불가, 안전성, 예측 가능, str, tuple, range가 해당된다.
  - 가변(mutable): 변경 가능, 유연성, 효율성, list, dict, set가 해당된다.
입력값을 리스트로 전환하기
```Python
numbers = list(map(int, input().split()))
```
형변환(type converstion): 한 데이터 타입을 다른 데이터 타입으로 변환하는 과정
- 암시적 형변환: 파이썬이 연산 중에 자동으로 데이터 타입을 변환하는 것. <br>파이썬이 데이터 손실을 막기 위해 더 정밀한 타입으로 자동 변환해주는 규칙.
- 명시적 형변환: 개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환하는 것. <br>서로 다른 타입의 데이터를 호환되도록 맞추는 과정.
  - 정수형: int()
  - 실수형: float()
  - 문자열: str()
  - 리스트: list()
  - 튜플: tuple()
  - 세트: set()
 
연산자
-
- 산술 연산자
- 복합 연산자
- 비교 연산자
  - == 연산자와 is 연산자
    - == 연산자: 값이 같은지를 비교(동등성, equality).
    - is 연산자: 객체 자체가 같은지를 비교(식별성, identity), 두 변수 완전히 동일한 메모리 주소의 객체를 가리키는지를 확인한다.
  - 싱글턴 객체(singleton): 특정 값에 대해 파이썬 전체에서 단 하나의 객체만 생성되어 재사용되는 특별한 객체, 여러 변수가 이 값을 가지더라도 모두 미리 만들어진 하나의 객체를 함께 가리키게 되므로 항상 같은 메모리 주소를 갖는다.
    - 파이썬의 대표적 싱글턴 객체: None, True, False 
- 논리 연산자: 논리곱(and), 논리합(or), 논리부정(not)
- 멤버십 연산자: 특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자
  - in: 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하는지를 확인
  - not in: in의 반대
- 시퀀스형 연산자: 시퀀스 자료형에 특별한 의미로 사용되는 연산자
  - **+**: 결합 연산자
  - *: 반복 연산자
---
단축 평가: 논리 연산에서 두번째 피연산자를 평가하지 않고 결과를 결정하는 동작, 필요한 계산만 하고 결과가 이미 정해졌다면 뒤에 있는 코드는 확인하지 않는다.
- 파이썬의 참과 거짓
  - 거짓으로 취급되는 값: False, 숫자 0, 빈 문자열 "", 빈 리스트 [], None
  - 참으로 취급되는 값: True, 거짓이 아닌 모든 값
- and 연산자
  - 하나라도 거짓이라면 거짓
  - 연산을 왼쪽에서 오른쪽으로 진행하다가, 처음 만나는 거짓값을 바로 반환
  - 만약 끝까지 갔는데 모든 값이 참이라면, 맨 마지막 참값을 반환
- or 연산자
  - 하나라도 참이라면 참
  - 연산을 왼쪽에서 오른쪽으로 진행하다가, 처음 만나는 참값을 바로 반환
  - 만약 끝까지 갔는데 모든 값이 거짓이라면, 맨 마지막 거짓값을 반환
- 단축 평가를 하는 이유
  - 코드 실행을 최적화하고 불필요한 연산을 피할 수 있도록 한다.
  - 논리 연산을 넘어, 코드의 흐름을 제어하고 오류를 방지하며 간결한 코드를 작성하는 데 매우 유용하게 사용되는 파이썬의 중요한 기능이다.
---
얕은 복사와 깊은 복사
- 참조 복사(메모리 복사)
```Python
a = [1, 2, 3]
b = a # 둘은 같은 개체를 가리킨다
b[0] = 10
print(f'a = {a}') # [10, 2, 3]
print(f'b = {b}') # [10, 2, 3]
print(a == b) # True
```
- 깊은 복사: 메모리의 다른 장소에 새로운 객체를 저장
```Python
a = [[1, 2], [3, 4]]
import copy
b = copy.deepcopy(a)
b[0][0] = 10
print(a) # [[1, 2], [3, 4]]
print(b) # [[10, 2], [3, 4]]
```
- 객체의 메모리 주소 확인하기
```print(id(object))``` 

- 얕은 복사: 표지만 복사하고 속 페이지는 공유하기
```Python
a = [1, [2, 3]]
b = a.copy()
```
함수(function)
-
- 특정 작업을 수행하기 위한 재사용 가능한 코드 묶음
- 재사용성이 높아지고, 코드의 가독성과 유지보수성을 향상시킨다.
- 함수 호출(function call): 함수를 실행하기 위해 함수의 이름을 사용하여 해당함수의 코드블록을 실행하는 것
  ```function_name(arguments)```
  input(parameter), body(docstring, function body), output(return value)로 구성된다.
  
  ```Python
  def make_sum(pram1, pram2):
      """ 이것은 두 수를 받아
      두 수의 합을 반환하는 함수입니다.
      >>> make_sum(1,2)
      3
      """
      return pram1 + pram2
  result = make_sum(100, 30)
  print(result) # 130
  ```
  
- 함수의 정의와 호출
  - 함수의 정의
    - 함수의 정의는 def 키워드로 시작
    - def 키워드 이후 함수의 이름을 작성
    - 괄호 안에 매개변수를 지정할 수 있음
    - 매개변수(parameter)는 함수에 전달되는 값
  - 함수 body
    - 콜론 다음에 들여쓰기 된 블록
    - 함수가 실행될 때 수행되는 코드를 정의
  - docstring
    - 함수 body 앞에 선택적으로 작성 가능한 함수 설명서
  - 함수 반환 값
    - 함수는 필요한 경우 결과를 반환할 수 있다. (print와 같은 함수는 반환값이 없다.)
    - return 키워드 이후 반환값을 명시해야 한다.
    - return 문은 함수의 실행을 종료하고, 결과를 호출 부분으로 반환한다.
    - 함수 내에서 return 문이 없다면 None이 반환된다.
  - 함수 호출
    - 함수를 사용하기 위해서는 호출이 필요하다.
    - 함수의 이름과 소괄호를 활용해 호출한다.
    - 필요한 경우 인자(arguments)를 전달해야 한다.
    - 호출 부분에서 전달된 인자는 함수 정의 시 작성한 매개변수에 대입된다.
- 매개변수와 인자
  - 매개변수(parameter): 함수의 정의할 때, 함수가 받을 값을 나타내는 변수
  - 인자(arguments): 함수를 호출할 때, 실제로 전달되는 값
    - 위치 인자(positional arguments): 함수 호출 시 인자의 위치에 따라 전달되는 인자. 위치 인자는 함수 호출시 반드시 값을 전달해야 한다.
    - 기본 인자 값(default argument values): 함수 정의에서 매개변수에 기본 값을 할당하는 것. 함수 호출 시 인자를 전달하지 않으면, 기본값이 매개변수에 할당된다.
    - 키워드 인자(keyword arguments): 함수 호출 시 인자의 이름과 함꼐 값을 전달하는 인자. 매개변수와 인자의 위치를 일치시키지 않고, 특정 매개변수에 값을 할당할 수 있다. 이 경우 인자의 순서는 중요하지 않으나 인자의 이름을 명시하여 전달해야 하며 키워드 인자는 위치 인자 뒤에 위치해야 한다.
    -  임의의 인자 목록(arbitrary argument lists): 정해지지 않은 개수의 인자를 처리하는 인자. 함수 정의 시 매개변수 앞에 '*'를 붙여 사용한다. 여러 개의 인자를 튜플로 처리할 수 있다.
    -  임의의 키워드 인자 목록(arbitrary keyword argument lists): 정해지지 않은 개수의 키워드 인자르 처리하는 인자. 함수 정의 시 매개변수 앞에 '**'를 붙여 사용한다. 여러 개의 인자를 딕셔너리로 묶어 처리한다.
    -  함수 인자 권장 작성 순서: 위치 -> 기본 -> 가변 -> 가변 키워드
- 재귀함수(recursive fuction): 함수 내부에서 자기 자신을 호출(재귀 호출)하는 함수. 재귀 호출의 결과를 이용하여 문제를 작은 단위의 문제로 분할하고, 분할된 문제들의 결과를 조합하여 최종 결과를 도출한다.
  - 재귀함수의 특징
    - 특정 알고리즘 식을 표현할 때 변수의 사용이 줄어들며, 코드의 가독성이 높아진다.
    - 1개 이상의 base case(종료되는 상황)가 존재하고, 수렴하도록 작성해야 한다.
  - 재귀함수의 목적
    - 문제의 자연스러운 표현: 복잡한 문제를 간결하고 직관적으로 표현 가능하다.
    - 코드 간결성: 상황에 따라 반복무보다 알고리즘 코드가 더 간결하고 명확해질 수 있다.
    - 수학적 문제 해결: 수학적 정의가 재귀적으로 표현되는 경우, 직접적인 구현이 가능하다.
- 내장 함수(built-in function): 파이썬이 기본적으로 제공하는 함수(별도의 import가 필요하지 않다)
- 범위(scope): 함수는 코드 내부에 local scope를 생성하며, 그 외의 공간은 gloabal scope로 구분한다.
  - scope
    - global scope: 코드 어디에서든 참조할 수 있는 공간
    - local scope: 함수가 만든 scope(함수 내부에서만 참조 가능)
  - variable
    - global variable(전역 변수): global scope에 정의된 변수
    - local variable(지역 변수): local scope에 정의된 변수
  - 변수의 수명주기(lifecycle)
    - built-in scope: 파이썬이 실행된 이후부터 영원히 유지된다.
    - gloabal scope: 모듈이 호출된 시점 이후 혹은 인터프리터가 끝날때까지 유지된다.
    - local scope: 함수가 호출될 때 생성되고, 함수가 종료될때까지 유지된다.
  - 이름 검색 규칙(name resolution, LEGB rule)
    1. Local scope
    2. Enclose scope
    3. Global scope
    4. Built-in scope
  - global 키워드
    - 변수의 스코프를 전역 범위로 지정하기 위해 사용하는 키워드. 일반적으로 함수 내에서 전역 변수를 수정하려는 경우에 사용한다.
    - 주의사항
      - global 키워드 선언 전에는 참조할 수 없다.
      - 매개변수에는 global 키워드를 사용할 수 없다.   
- 패킹 & 언패킹
  - 패킹(packing): 여러 개의 데이터를 하나의 컬렉션으로 모아 담는 과정
    - 여러 개의 값을 하나의 튜플로 묶는 파이썬의 기본 동작
    - 한 변수에 콤마로 구분된 값을 넣으면 자동으로 튜플로 처리된다.
```Python
packed_values = 1, 2, 3, 4, 5
print(packed_values)  # (1, 2, 3, 4, 5)
```
  - 언패킹(unpacking): 컬렉션에 담겨있는 데이터들을 개별 요소로 펼쳐 놓는 과정
    - 튜플이나 리스트 등의 객체의 요소들을 개별 변수에 할당
    - 시퀀스 언패킹(sequence unpacking) 또는 다중 할당(multiple assignment)이라고 부르기도 한다.
```Python
a, b, c, d, e = packed_values
print(a, b, c, d, e)  # 1 2 3 4 5
```
- 람다 표현식(Lambda expressions): 익명 함수를 만드는데 사용되는 표현식. 한 줄로 간단한 함수를 정의한다.
  - 표기법 ```lambda 매개변수: 표현식```
    - lambda 키워드: 람다 함수를 선언하기 위해 사용되는 키워드
    - 매개변수: 함수에 전달되는 매개변수들, 여러개의 매개변수가 있을 경우 쉼표로 구분한다.
    - 표현식: 함수의 실행되는 코드 블록, 결과값을 반환하는 표현식으로 작성한다.  
    
