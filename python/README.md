# Python

인터프리터 vs 컴파일러
  - 컴파일러: 전체 코드를 번역한 후 한줄씩 실행
    - 장점: 빠르다
  - 인터프리터: 코드를 한줄씩 번역하며 실행
    - 장점: 디버깅이 편하다. (개발과 테스트가 빠름)
프로그램의 실행 속도 면에서는 컴파일러가 우수, **파이썬**은 인터프리터 언어!

파이썬이 갖는 장점
  - 쉽고 간결한 문법: 읽기 쉽고 쓰기 쉬운 문법을 가지고 있어 쉽게 배우고 활용할 수 있음
  - 커뮤니티의 지원: 세계적인 규모의 풍부한 온라인 포럼 및 커뮤니티 생태계를 형성하고 있음
  - 광범위한 응용 분야: 웹 개발, 데이터 분석, 인공지능, 자동화 스크립트 등 다양한 분야에서 사용함

표현식(expression): 하나의 '값'으로 평가될 수 있는 모든 코드
  - 예시: 3 + 5, x > 10, 5 * 4
값(value): 표현식이 평가된 결과, 더 이상 계산되거나 평가될 수 없는, 프로그램의 가장 기본적인 데이터 조각
  - 예시: 103.14(숫자값), "안녕하세요"(문자열 값), True(불리언 값) 


자료형
-

list: 여러개의 값을 순서대로 저장하는, 변경 가능한(**mutable**) 시퀀스 자료형
- 대괄호 안에 값들을 쉼표로 구분하여 만든다.
- 숫자, 문자열, 혹은 다른 리스트 등 모든 종류의 데이터를 담을 수 있다.
- 값을 추가, 수정, 삭제 등 자유롭게 변경이 가능하다.

```Python
my_list_1 = []
my_list_2 = [1, 'a', 3, 'b', 5]
my_list_3 = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]
```
리스트의 시퀀스 특징
- 리스트는 시퀀스이므로, 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능하다.

```Python
# 인덱싱
print(my_list[1])  # a

# 슬라이싱
print(my_list[2:4])  # [3, 'b']
print(my_list[:3])  # [1, 'a', 3]
print(my_list[3:])  # ['b', 5]
print(my_list[::2])  # [1, 3, 5]
print(my_list[::-1])  # [5, 'b', 3, 'a', 1]

# 길이
print(len(my_list))  # 5
```
- 중첩 리스트(nested list): 다른 리스트를 값으로 가지는 리스트
- 중첩 리스트에 접근하기: 인덱스를 연달아 사용하여 안쪽 리스트의 값에 접근할 수 있다.
```Python
# 중첩된 리스트 접근
my_list = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]
print(len(my_list))  # 5
print(my_list[4][-1])  # !!!
print(my_list[-1][1][0])  # w
```
- 리스트의 가변성: 한번 생성된 리스트는 그 내용을 자유롭게 수정, 추가, 삭제할 수 있다. 문자열이 불변성(immutable)을 갖는 시퀀스인 것과 대조적이다.

```Python
# 리스트는 가변
# 1. 인덱싱으로 값 수정
my_list = [1, 2, 3, 4, 5]
my_list[1] = 'two'
print(my_list)  # [1, 'two', 3, 4, 5]

# 2. 슬라이싱으로 값 수정
my_list = [1, 2, 3, 4, 5]
my_list[2:4] = ['three', 'four']
print(my_list)  # [1, 2, 'three', 'four', 5]
```
- 리스트의 활용법(메서드)
```Python
numbers = []

numbers.append(3) # append: 가장 뒤에 데이터를 추가
numbers.append(2)
numbers.append(1)
numbers.append(5)
print(numbers) # [3, 2, 1, 5]
print(numbers[0]) # 3
print(numbers[-1]) # 5

numbers.pop() # pop(): 맨 뒤의 데이터를 삭제
print(numbers) # [3, 2, 1]
numbers.pop(1) # 해당 인덱스에 위치한 데이터를 삭제
print(numbers) # [3, 1]
```

튜플(tuple): 여러개의 값을 순서대로 저장하는 변경이 불가능한 시퀀스 자료형
- 소괄호 안에 값들을 쉼표로 구분하여 만든다.
- 모든 종류의 데이터를 담을 수 있다.
- 리스트와 거의 모든 면에서 비슷하지만, 한번 만들어지면 절대 수정할 수 없다는 결정적인 차이점을 갖는다.
```Python
# 튜플 표현
my_tuple_1 = ()
my_tuple_2 = (1,) # 단일 요소 튜플의 경우 반드시 후행 쉼표가 와야한다.
my_tuple_3 = (1, 'a', 3, 'b', 5)
my_tuple_4 = 1, 'hello', 3.14, True # 소괄호 없이도 튜플을 만들 수 있다.
```
- 튜플 역시 시퀀스 자료형이므로, 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능하다.
```Python
# 인덱싱
print(my_tuple[1])  # a

# 슬라이싱
print(my_tuple[2:4])  # (3, 'b')
print(my_tuple[:3])  # (1, 'a', 3)
print(my_tuple[3:])  # ('b', 5)
print(my_tuple[::2])  # (1, 3, 5)
print(my_tuple[::-1])  # (5, 'b', 3, 'a', 1)

# 길이
print(len(my_tuple))  # 5
```
- 튜플의 사용처: 튜플의 불변 특성을 사용하여 내부 동작과 안전한 데이터 전달에 사용된다. (다중 할당, 값 교환, 함수 다중 반환 값 등)
- 사용자가 튜플을 직접 사용하는 경우는 거의 없다.

range: 연속된 정수 시퀀스를 생성하는 불변성을 갖는 자료형
- 주로 반복분과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 유용하다.
- 실제로 모든 숫자를 메모리에 저장하는 대신, 시작값, 끝값, 간격이라는 규칙만 기억하여 메모리를 매우 효율적으로 사용한다.
- 주로 반복문과 함께 활용된다.
```python
range(start, stop, step)
```
- range 매개변수별 특징
  - range(stop)
    - 매개 변수가 하나면 stop으로 인식한다.
    - start는 0, step은 1이 디폴트
    - range(5) -> 0, 1, 2, 3, 4
  - range(start, stop)
    - 매개 변수가 두개면 start와 stop으로 인식한다.
    - step은 1이 디폴트
    - range(2, 5) -> 2, 3, 4
  - range(start, stop, step)
    - 모든 매개변수를 직접 지정하는 경우
    - range(2, 10, 2) -> 2, 4, 6, 8

딕셔너리(dict): key - value 쌍으로 이루어진 순서와 중복이 없는(비시퀀스) 변경 가능한 자료형
- 표현법: 중괄호 안에 값들이 쉼표로 구분되어 있다.
  - 값 1개는 키와 값이 쌍으로 이루어져 있다.
    - 키(key): 값을 식별하기 위한 고유한 이름표
      - 고유해야 하기 때문에 중복될 수 없다.
      - 변경 불가능한 자료형만 가능하다. (str, int, float, tuple)
    - 값(value): 키에 해당하는 실제 데이터
    - **※**각 값에는 순서가 존재하지 않는다.
- 값 접근법
  - 키를 사용하여 값을 꺼내올 수 있다.
  - 키에 접근할 때는 대괄호를 사용한다.
```python
my_dict = {'name': '홍길동', 'age': 25}
print(my_dict['name'])  # '홍길동'
print(my_dict['test'])  # KeyError: 'test'
```
- 값 추가 및 변경
```Python
my_dict = {'apple': 12, 'list': [1, 2, 3]}
# 추가
my_dict['banana'] = 50
print(my_dict)  # {'apple': 12, 'list': [1, 2, 3], 'banana': 50}
# 변경
my_dict['apple'] = 100
print(my_dict)  # {'apple': 100, 'list': [1, 2, 3], 'banana': 50}
```
- 키의 존재 유무 검사
```Python
print(di.get(key)) # value를 출력
print(di.get('없는 키')) # None을 출력
```

세트(set): 순서와 중복이 없는 변경 가능한 자료형
- 중괄호 안에 값들을 쉼표로 구분하여 만든다.
- 수학에서의 집합과 동일한 연산 처리가 가능하다.
- ※ 비어있는 딕셔너리와의 혼동을 피하기 위해, 비어있는 세트는 반드시 set() 함수로 만들어야 한다.

세트의 집합 연산: 세트는 수학의 집합 개념을 그대로 가져와, 두 데이터 그룹 간의 관계를 파악하는데 매우 효과적이다.
```Python
my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}

# 합집합
print(my_set_1 | my_set_2)  # {1, 2, 3, 6, 9}

# 차집합
print(my_set_1 - my_set_2)  # {1, 2}

# 교집합
print(my_set_1 & my_set_2)  # {3}

# 대칭차집합
print(my_set_1 ^ my_set_2) # {1, 2, 6, 9}

# 부분집합 확인
print(my_set_1 < my_set_2) # False
```
그 외의 데이터 타입들(other types)
- None: 파이썬에서 값이 없을 표현하는 특별한 데이터 타입. <br>숫자 0이나 빈 문자열과는 다르게 값이 존재하지 않음 또는 아직 정해지지 않음 이라는 상태를 나타내기 위해 사용된다.
- Boolean: 참(True)과 거짓(False) 두가지 값만 갖는 데이터 타입 <br>비교/논리 연산의 평가 결과로 사용되며 주로 조건/반복문과 함께 사용된다.
- Collection: 여러개의 값을 하나로 묶어 관리하는 자료형들을 통칭하는 말(str, list, tuple, range, set, dict)
---
불변과 가변
- 컬렉션 타입은 생성 후 내용을 변경할 수 있는지 없는지에 따라 불변과 가변 두 그룹으로 나뉜다.
  - 불변(immutable): 변경 불가, 안전성, 예측 가능, str, tuple, range가 해당된다.
  - 가변(mutable): 변경 가능, 유연성, 효율성, list, dict, set가 해당된다.
입력값을 리스트로 전환하기
```Python
numbers = list(map(int, input().split()))
```
형변환(type converstion): 한 데이터 타입을 다른 데이터 타입으로 변환하는 과정
- 암시적 형변환: 파이썬이 연산 중에 자동으로 데이터 타입을 변환하는 것. <br>파이썬이 데이터 손실을 막기 위해 더 정밀한 타입으로 자동 변환해주는 규칙.
- 명시적 형변환: 개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환하는 것. <br>서로 다른 타입의 데이터를 호환되도록 맞추는 과정.
  - 정수형: int()
  - 실수형: float()
  - 문자열: str()
  - 리스트: list()
  - 튜플: tuple()
  - 세트: set()
 
연산자
-
- 산술 연산자
- 복합 연산자
- 비교 연산자
  - == 연산자와 is 연산자
    - == 연산자: 값이 같은지를 비교(동등성, equality).
    - is 연산자: 객체 자체가 같은지를 비교(식별성, identity), 두 변수 완전히 동일한 메모리 주소의 객체를 가리키는지를 확인한다.
  - 싱글턴 객체(singleton): 특정 값에 대해 파이썬 전체에서 단 하나의 객체만 생성되어 재사용되는 특별한 객체, 여러 변수가 이 값을 가지더라도 모두 미리 만들어진 하나의 객체를 함께 가리키게 되므로 항상 같은 메모리 주소를 갖는다.
    - 파이썬의 대표적 싱글턴 객체: None, True, False 
- 논리 연산자: 논리곱(and), 논리합(or), 논리부정(not)
- 멤버십 연산자: 특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자
  - in: 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하는지를 확인
  - not in: in의 반대
- 시퀀스형 연산자: 시퀀스 자료형에 특별한 의미로 사용되는 연산자
  - **+**: 결합 연산자
  - *: 반복 연산자
---
단축 평가: 논리 연산에서 두번째 피연산자를 평가하지 않고 결과를 결정하는 동작, 필요한 계산만 하고 결과가 이미 정해졌다면 뒤에 있는 코드는 확인하지 않는다.
- 파이썬의 참과 거짓
  - 거짓으로 취급되는 값: False, 숫자 0, 빈 문자열 "", 빈 리스트 [], None
  - 참으로 취급되는 값: True, 거짓이 아닌 모든 값
- and 연산자
  - 하나라도 거짓이라면 거짓
  - 연산을 왼쪽에서 오른쪽으로 진행하다가, 처음 만나는 거짓값을 바로 반환
  - 만약 끝까지 갔는데 모든 값이 참이라면, 맨 마지막 참값을 반환
- or 연산자
  - 하나라도 참이라면 참
  - 연산을 왼쪽에서 오른쪽으로 진행하다가, 처음 만나는 참값을 바로 반환
  - 만약 끝까지 갔는데 모든 값이 거짓이라면, 맨 마지막 거짓값을 반환
- 단축 평가를 하는 이유
  - 코드 실행을 최적화하고 불필요한 연산을 피할 수 있도록 한다.
  - 논리 연산을 넘어, 코드의 흐름을 제어하고 오류를 방지하며 간결한 코드를 작성하는 데 매우 유용하게 사용되는 파이썬의 중요한 기능이다.
---
얕은 복사와 깊은 복사
- 참조 복사(메모리 복사)
```Python
a = [1, 2, 3]
b = a # 둘은 같은 개체를 가리킨다
b[0] = 10
print(f'a = {a}') # [10, 2, 3]
print(f'b = {b}') # [10, 2, 3]
print(a == b) # True
```
- 깊은 복사: 메모리의 다른 장소에 새로운 객체를 저장
```Python
a = [[1, 2], [3, 4]]
import copy
b = copy.deepcopy(a)
b[0][0] = 10
print(a) # [[1, 2], [3, 4]]
print(b) # [[10, 2], [3, 4]]
```
- 객체의 메모리 주소 확인하기
```print(id(object))``` 

- 얕은 복사: 표지만 복사하고 속 페이지는 공유하기
```Python
a = [1, [2, 3]]
b = a.copy()
```
함수(function)
-
- 특정 작업을 수행하기 위한 재사용 가능한 코드 묶음
- 재사용성이 높아지고, 코드의 가독성과 유지보수성을 향상시킨다.
- 함수 호출(function call): 함수를 실행하기 위해 함수의 이름을 사용하여 해당함수의 코드블록을 실행하는 것
  ```function_name(arguments)```
  input(parameter), body(docstring, function body), output(return value)로 구성된다.
  
  ```Python
  def make_sum(pram1, pram2):
      """ 이것은 두 수를 받아
      두 수의 합을 반환하는 함수입니다.
      >>> make_sum(1,2)
      3
      """
      return pram1 + pram2
  result = make_sum(100, 30)
  print(result) # 130
  ```
  
- 함수의 정의와 호출
  - 함수의 정의
    - 함수의 정의는 def 키워드로 시작
    - def 키워드 이후 함수의 이름을 작성
    - 괄호 안에 매개변수를 지정할 수 있음
    - 매개변수(parameter)는 함수에 전달되는 값
  - 함수 body
    - 콜론 다음에 들여쓰기 된 블록
    - 함수가 실행될 때 수행되는 코드를 정의
  - docstring
    - 함수 body 앞에 선택적으로 작성 가능한 함수 설명서
  - 함수 반환 값
    - 함수는 필요한 경우 결과를 반환할 수 있다. (print와 같은 함수는 반환값이 없다.)
    - return 키워드 이후 반환값을 명시해야 한다.
    - return 문은 함수의 실행을 종료하고, 결과를 호출 부분으로 반환한다.
    - 함수 내에서 return 문이 없다면 None이 반환된다.
  - 함수 호출
    - 함수를 사용하기 위해서는 호출이 필요하다.
    - 함수의 이름과 소괄호를 활용해 호출한다.
    - 필요한 경우 인자(arguments)를 전달해야 한다.
    - 호출 부분에서 전달된 인자는 함수 정의 시 작성한 매개변수에 대입된다.
- 매개변수와 인자
  - 매개변수(parameter): 함수의 정의할 때, 함수가 받을 값을 나타내는 변수
  - 인자(arguments): 함수를 호출할 때, 실제로 전달되는 값
    - 위치 인자(positional arguments): 함수 호출 시 인자의 위치에 따라 전달되는 인자. 위치 인자는 함수 호출시 반드시 값을 전달해야 한다.
    - 기본 인자 값(default argument values): 함수 정의에서 매개변수에 기본 값을 할당하는 것. 함수 호출 시 인자를 전달하지 않으면, 기본값이 매개변수에 할당된다.
    - 키워드 인자(keyword arguments): 함수 호출 시 인자의 이름과 함꼐 값을 전달하는 인자. 매개변수와 인자의 위치를 일치시키지 않고, 특정 매개변수에 값을 할당할 수 있다. 이 경우 인자의 순서는 중요하지 않으나 인자의 이름을 명시하여 전달해야 하며 키워드 인자는 위치 인자 뒤에 위치해야 한다.
    -  임의의 인자 목록(arbitrary argument lists): 정해지지 않은 개수의 인자를 처리하는 인자. 함수 정의 시 매개변수 앞에 '*'를 붙여 사용한다. 여러 개의 인자를 튜플로 처리할 수 있다.
    -  임의의 키워드 인자 목록(arbitrary keyword argument lists): 정해지지 않은 개수의 키워드 인자르 처리하는 인자. 함수 정의 시 매개변수 앞에 '**'를 붙여 사용한다. 여러 개의 인자를 딕셔너리로 묶어 처리한다.
    -  함수 인자 권장 작성 순서: 위치 -> 기본 -> 가변 -> 가변 키워드
- 재귀함수(recursive fuction): 함수 내부에서 자기 자신을 호출(재귀 호출)하는 함수. 재귀 호출의 결과를 이용하여 문제를 작은 단위의 문제로 분할하고, 분할된 문제들의 결과를 조합하여 최종 결과를 도출한다.
  - 재귀함수의 특징
    - 특정 알고리즘 식을 표현할 때 변수의 사용이 줄어들며, 코드의 가독성이 높아진다.
    - 1개 이상의 base case(종료되는 상황)가 존재하고, 수렴하도록 작성해야 한다.
  - 재귀함수의 목적
    - 문제의 자연스러운 표현: 복잡한 문제를 간결하고 직관적으로 표현 가능하다.
    - 코드 간결성: 상황에 따라 반복무보다 알고리즘 코드가 더 간결하고 명확해질 수 있다.
    - 수학적 문제 해결: 수학적 정의가 재귀적으로 표현되는 경우, 직접적인 구현이 가능하다.
- 내장 함수(built-in function): 파이썬이 기본적으로 제공하는 함수(별도의 import가 필요하지 않다)
- 범위(scope): 함수는 코드 내부에 local scope를 생성하며, 그 외의 공간은 gloabal scope로 구분한다.
  - scope
    - global scope: 코드 어디에서든 참조할 수 있는 공간
    - local scope: 함수가 만든 scope(함수 내부에서만 참조 가능)
  - variable
    - global variable(전역 변수): global scope에 정의된 변수
    - local variable(지역 변수): local scope에 정의된 변수
  - 변수의 수명주기(lifecycle)
    - built-in scope: 파이썬이 실행된 이후부터 영원히 유지된다.
    - gloabal scope: 모듈이 호출된 시점 이후 혹은 인터프리터가 끝날때까지 유지된다.
    - local scope: 함수가 호출될 때 생성되고, 함수가 종료될때까지 유지된다.
  - 이름 검색 규칙(name resolution, LEGB rule)
    1. Local scope
    2. Enclose scope
    3. Global scope
    4. Built-in scope
  - global 키워드
    - 변수의 스코프를 전역 범위로 지정하기 위해 사용하는 키워드. 일반적으로 함수 내에서 전역 변수를 수정하려는 경우에 사용한다.
    - 주의사항
      - global 키워드 선언 전에는 참조할 수 없다.
      - 매개변수에는 global 키워드를 사용할 수 없다.   
- 패킹 & 언패킹
  - 패킹(packing): 여러 개의 데이터를 하나의 컬렉션으로 모아 담는 과정
    - 여러 개의 값을 하나의 튜플로 묶는 파이썬의 기본 동작
    - 한 변수에 콤마로 구분된 값을 넣으면 자동으로 튜플로 처리된다.
```Python
packed_values = 1, 2, 3, 4, 5
print(packed_values)  # (1, 2, 3, 4, 5)
```
  - 언패킹(unpacking): 컬렉션에 담겨있는 데이터들을 개별 요소로 펼쳐 놓는 과정
    - 튜플이나 리스트 등의 객체의 요소들을 개별 변수에 할당
    - 시퀀스 언패킹(sequence unpacking) 또는 다중 할당(multiple assignment)이라고 부르기도 한다.
```Python
a, b, c, d, e = packed_values
print(a, b, c, d, e)  # 1 2 3 4 5
```
- 람다 표현식(Lambda expressions): 익명 함수를 만드는데 사용되는 표현식. 한 줄로 간단한 함수를 정의한다.
  - 표기법 ```lambda 매개변수: 표현식```
    - lambda 키워드: 람다 함수를 선언하기 위해 사용되는 키워드
    - 매개변수: 함수에 전달되는 매개변수들, 여러개의 매개변수가 있을 경우 쉼표로 구분한다.
    - 표현식: 함수의 실행되는 코드 블록, 결과값을 반환하는 표현식으로 작성한다.  
---    
데이터 구조(자료 구조, data structure)
-
각 데이터의 효율적인 저장, 관리를 위한 구조를 나눠 놓은 것.<br>
단순히 데이터를 묶는 것을 넘어, 프로그램의 성능과 효율성, 유지보수성에 큰 영향을 미치는 핵심적인 개념
- 메서드(method): 객체에 속한 함수. 객체가 특정 작업을 수행하도록 정의된 함수. 적용될 데이터의 종류에 따라 사용 가능한 메서드가 다르다.
  - 메서드의 호출: ```데이터 타입 객체.메서드()``` <br>
  ```'hello'.capitalize()```
  - 시퀀스 자료형
    - 문자열 조회/탐색 및 검증 메서드
      - ```s.find(x)```: x의 첫번째 위치를 반환. 없으면 -1을 반환
      - ```s.index(x)```: x의 첫번째 위치를 반환. 없으면 오류발생
      - ```s.isupper(x)```: 문자열 내의 모든 문자가 대문자인지 확인
      - ```s.islower(x)```: 문자열 내의 모든 문자가 소문자인지 확인
      - ```s.isalpha(x)```: 문자열 내의 모든 문자가 알파벳인지 확인
      - 메서드 이름이 is~ 인 경우는 주로 반환값이 boolean.
    - 문자열 조작 메서드(새로운 문자열 반환)
      - ```s.replace(old, new[,count])```: 바꿀 대상 글자를 새로운 글자로 바꿔서 변환, 선택인자 count를 사용함으로써 몇개의 old 문자열을 교체할지 정할 수 있다.
      - ```s.strip([chars])```: 공백이나 특정 문자를 제거
      - ```s.split(sep=None, maxsplit=-1)```: 'sep'를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를 반환
      - ```'seperator'.join(iterable)```: 구분자로 iterable의 문자열을 연걸한 문자열을 반환
      - ```s.capitalize```: 문자열의 가장 첫자를 대문자, 나머지를 소문자로 변환
      - ```s.title```: 문자열의 각 단어의 첫 자를 대문자, 나머지를 소문자로 변환
      - ```s.upper```: 문자열의 모든 알파벳을 대문자로 변환
      - ```s.lower```: 문자열의 모든 알파벳을 소문자로 변환
      - ```s.swapcase```: 문자열의 모든 알파벳의 소문자-대문자 여부를 전환
    - 리스트 값 추가 및 삭제 메서드: 리스트는 가변 객체이므로 문자열과 다르게 조작 결과가 리스트에 직접 적용된다. 즉, 반환값이 없다.
      - ```L.append(x)```: 리스트의 마지막에 항목 x를 추가
      - ```L.extend(m)```: Iterable m의 모든 항목들을 리스트 끝에 추가
      - ```L.insert(i, x)```: 리스트 인덱스 i에 항목 x를 삽입
      - ```L.remove(x)```: 리스트의 첫번째 항목 x를 제거, 항목이 존재하지 않을 경우 ValueError
      - ```L.pop()```: 리스트의 가장 마지막 항목을 **반환** 후 제거
        - ```L.pop(i)```: 리스트의 인덱스 i에 있는 항목을 반환 후 제거
      - ```L.clear()```: 리스트의 모든 항목 삭제
      - ```L.index(x)```: 리스트에서 첫번째로 일치하는 항목 x의 인덱스를 반환
      - ```L.count(x)```: 리스트에서 항목 x의 개수를 반환
      - ```L.reverse()```: 리스트의 순서를 역순으로 변경
      - ```L.sort()```: 리스트를 정렬(매개변수 사용 가능)
        - 디폴트는 오름차순
        - 내림차순의 경우 매개변수에 reverse=True를 사용한다.
    - 문자 유형 판별 메서드
      - ```isdecimal()```: 문자열이 모두 숫자 문자(0~9)로만 이루어져 있어야 True
      - ```isdigit()```: 유니코드 숫자도 인식
      - ```isnumeric()```: 분수, 지수, 루트 기호도 숫자로 인식
  - 비시퀀스 자료형
    - 딕셔너리 메서드
      - 주요 메서드
        - ```D.get(k)```: 키 k에 연결된 값을 반환(키가 없을 경우 None을 반환)
          - ```D.get(k,v)```: 키 k에 연결된 값을 반환하거나 키가 없으면 기본 값으로 v를 반환
        - ```D.keys()```: 딕셔너리 D의 키를 모은 객체를 반환
        - ```D.values()```: 딕셔너리 D의 값을 모은 객체를 반환
        - ```D.items()```: 딕셔너리 D의 키/값 쌍을 모은 객체를 반환
        - ```D.pop(k)```: 딕셔너리 D에서 키 k를 제거하고 연결됐던 값을 반환(없을 경우 오류 발생)
          - ```D.pop(k, v)```: 딕셔너리 D에서 키 k를 제거하고 연결됐던 값을 반환(없을 경우 v 반환)
      - 참고용 메서드
        - ```D.clear```: 딕셔너리 D의 모든 키/값 쌍을 제거
        - ```D.setdefault(k [,v])``: 딕셔너리 D에서 키 k와 연결된 값을 반환. k가 D의 키가 아닐 경우 값 v와 연결한 키 k를 D에 추가하고 v를 반환한다.
        - ```D.update(other)```: other 내 각 키에 대해 D에 있는 키면 D에 있는 그 키의 값을 other에 있는 값을 대체. other에 있는 각 키에 대해 D에 없는 키면 키/값 쌍을 D에 추가
    - 세트 메서드
      - 주요 메서드
        - ```s.add(x)```: 세트 s에 항목 x를 추가. 이미 있다면 변화 없음.
        - ```s.remove(x)```: 세트 s에서 항목 x를 제거. 없다면 key error
      - 참고용 메서드:
        - ```s.update(iterable)```: 세트 s에 다른 iterable 요소를 추가
        - ```s.clear()```: 세트 s의 모든 항목을 제거
        - ```s.pop```: 세트 s에서 **임의**의(완전한 무작위가 아님) 항목을 반환하고 제거
        - ```s.discard(x)```: 세트 s에서 항목 x를 제거
  - 해시 테이블(hash table): 키와 값을 짝지어 저장하는 자료구조
    - 원리
      1. 키를 해시 함수를 통해 해시 값으로 변환
      2. 변환된 해시 값을 인덱스로 삼아 데이터를 저장하거나 찾음
      3. 이로 인해 검색, 삽입, 삭제를 매우 빠르게 수행 
    - 해시(hash): 임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환하는 것. 생성된 해시 값(고유한 정수)은 해당 데이터를 식별하는 지문 역할을 한다. 파이썬에서는이 해시 값을 이용해 해시 테이블에 데이터를 저장하고 이 변환을 수행하는 것이 해시 함수이다.
    - 해시 함수(hash function): 임의 길이 데이터를 입력 받아 고정 길이(정수)로 변환해주는 함수. 이 정수가 해시 값이 된다.
      - 파이썬에서의 해시 함수
        - 정수: 같은 정수는 항상 같은 해시 값을 갖는다.
        - 문자열: 문자열 해시 시, 파이썬 인터프리터 실행 시 설정되는 난수 시드가 달라질 수 있다.(보안상의 이유) 각 실행마다 해시 값이 달라질 수 있다.
    - set
      - 각 요소를 해시 함수로 변환해 나온 해시 값에 맞춰 해시 테이블 내부 버킷(bucket)에 위치시킨다.
      - 따라서, 요소의 순서가 아닌 버킷 위치(인덱스)가 요소의 위치를 결정하며 set는 순서를 보장하지 않는다.
    - dict
      - 키 -> 해시 함수 -> 해시 값 -> 해시 테이블에 저장
      - 단 set와 달리 개발자의 편의를 위해 '삽입 순서'는 유지한다는 것이 언어 사양에 따라 보장된다.(python 3.7 이상) 단, 이것이 딕셔너리 자료형에 순서가 존재함을 의미하는 것은 아니다.
        - 즉, 키를 추가한 순서대로 반복문을 순회할 때 나오게 된다.
        - 사용자에게 보여지는 키 순서는 삽입 순서가 유지되도록 설계된 것이다.
    - hashable: hash() 함수에 넣어 해시 값을 구할 수 있는 객체. 대부분의 불변 타입은 해시 가능하다. (int, float, str, tuple) 가변 객체의 경우 값이 변하면 해시 값도 달라질 수 있어 해시 테이블 무결성이 깨지기 때문에 해시 불가능하다.
  - 메서드 체이닝(method chaining): 여러 메소드를 연속해서 호출하는 방식
    - 예시
    ```Python
    text = 'heLLo, woRld!'
    new_text = text.swapcase().replace('l', 'z')
    print(new_text) # HEzzO, WOrLD!
    ```
    - 주의사항
      - 메서드가 객체를 반환하는 경우에만 체이닝이 가능하다.
      - None을 반환하는 경우에는 체이닝이 불가능하다. 
        - append(), sort()

- 객체와 참조
  - 가변/불변 객체
    - 가변 객체 (mutable): 생성 후 내용을 변경할 수 있는 객체
      - list, dict, set
    - 불변 객체 (immutable): 생성 후 내용을 변경할 수 없는 객체
      - int, float, str, tuple
  - 변수 할당
    - 파이썬에서 변수 할당은 객체에 대한 참조를 생성하는 과정. 변수는객체의 메모리 주소를 가리키는 label 역할을 한다. 
    - '='연산자를 사용하여 변수에 값을 할당하게 되면 새로운 객체가 생성되거나 기존 객체에 대한 참조가 생성된다.
      - 새로운 객체 생성 후 참조: 할당되는 값이 새로운 객체일 경우, 파이썬은 먼저 해당 객체를 메모리에 만들고 변수가 그 객체를 가리키게 한다.
      - 기존 객체에 대한 참조: 이미 메모리에 존재하는 객체를 변수에 할당하면, 새로운 객체를 만들지 않고 해당 객체에 대한 참조만 생성한다.
  - 가변/불면 객체의 메모리 관리 방식
    - 가변 객체: 객체의 내용이 변경되어도 같은 메모리 주소를 유지
      - 성능 최적화: 내용 수정이 빈번할 때, 새로운 객체를 생성하는 대신 기존 객체를 직접 수정할 수 있다. 이로 인해 객체 생성 및 삭제에 드는 비용을 절감하여 성능을 향상시킬수 있다.
      - 메모리 효율성: 크기가 큰 데이터를 효율적으로 수정할 수 있다.
    - 불변 객체: 새로운 값을 할당하면 새로운 객체가 생성되고, 변수는 새 객체를 참조한다.
      - 성능 최적화: 변경이 불가능하므로, 여러 변수가 동일한 객체를 안전하게 공유할 수 있다.
      - 메모리 효율성: 동일한 값을 가진 여러 변수가 같은 객체를 참조할 수 있어 메모리 사용을 최소화할 수 있다.
  - 얕은 복사(shallow copy): 객체의 최상위 요소만 새로운 메모리에 복사하는 방법. 내부에 중첩된 객체가 있다면 그 객체의 참조만 복사된다.
    - 리스트 슬라이싱
    ```Python
    a = [1, 2, 3]
    b = a[:] # 원본 리스트와 동일한 내용의 새로운 리스트를 생성
    print(a) # [1, 2, 3]
    print(b) # [1, 2, 3]
    ```
      - 리스트에 복사되는 것은 요소 자체의 값이 아니라 해당 요소들이 참조하는 **주소**이다.
    - copy() 메서드
    ```Python
    a = [1, 2, 3]
    b = a.copy()
    ```
    - list() 함수
    ```Python
    a = [1, 2, 3]
    b = list(a)
    a[0] = 100
    print(a) = [100, 2, 3] # 원본 리스트의 요소만 변경됨
    print(b) = [1, 2, 3] 
    ```
  - 깊은 복사(deep copy): 객체의 모든 수준의 요소를 새로운 메모리에 복사하는 방법. 중첩된 객체까지 모두 새로운 객체로 생성된다.
    - copy 모듈에서 제공하는 deepcopy() 함수를 사용한다.
    ```Python
    import copy
    new_object = copy.deepcopy(original_object)
    ```
---
List comprehension
-
간결하고 효율적인 리스트 생성 방법.
```Python
[expression for 변수 in iterable]
list(expression for 변수 in iterable)

[expression for 변수 in iterable if 조건식]
list(expression for 변수 in iterable if 조건식)
```
- list comprehension을 활용한 2차원 배열 생성(인접행렬 생성)
```Python
data1 = [[0] * (5) for _ in range(5)]
또는
data2 = [[0 for _ in range(5)] for _ in range(5)]
# _ : 반복을 돌면서 변수에 저장하고 싶은 값이 없을 때 사용하는 변수명
```

---
