JS
---
DOM(Document Object Model): 웹페이지(document)를 구조화된 객체로 제공하여 프로그래밍 언어가 페이지 구조에 접근할 수 있는 방법을 제공.
DOM API: 다른 프로그래밍 언어가 웹페이지에 접근 및 조작할수 있도록 페이지 요소들을 객체 형태로 제공하며 관련 메서드도 함께 제공한다.
- document 객체: 웹페이지를 나타내는 DOM 트리의 최상위 객체. HTML문서의 모든 콘텐츠에 접근하고 조작할 수 있는 진입점이 된다.
- DOM에서 모든 요소, 속성, 텍스트는 하나의 객체이며, document 객체의 하위 객체로 구성된다.
- DOM tree: html 태그를 나타내는 요소들의 node는 문서의 구조를 결정한다. 이들은 다시 자식 노드를 가질 수 있다. (객체 간 상속 구조가 존재한다)
- 웹페이지를 동적으로 만들기 == 웹페이지를 조작하기
  - 조작하고자 하는 요소를 선택(혹은 탐색)하고 선택된 요소의 콘텐츠 또는 속성을 조작한다.
  - 선택 메서드
    - document.querySelector(selector)
      - 제공한 선택자와 일치하는 첫번째 요소를 한개 선택한다.
      - 제공한 선택자를 만족하는 첫번째 요소 객체를 반환한다. (없다면 null을 반환)
    - document.querySelectorAll(selector)
      - 제공한 선택자와 일치하는 여러 요소를 선택한다.
      - 제공한 선택자를 만족하는 nodelist를 반환한다.
  - 조작 메서드
    - 속성 조작
      - 클래스 속성(classList property) 조작 메서드: 요소의 클래스 목록을 DOMTokenList(유사 배열) 형태로 반환
        - element.classList.add(): 지정한 클래스 값을 추가
        - element.classList.remove(): 지정한 클래스 값을 제거
        - element.classList.toggle(): 클래스가 존재한다면 제거하고 false를 반환(존재하지 않으면 클래스를 추가하고 True를 반환)
      - 일반 속성 조작 메서드
        - Element.getAttribute(): 해당 요소에 지정된 값을 반환
        - Element.setAttribute(): 지정된 요소의 속성 값을 설정. 속성이 이미 있다면 기존 값을 갱신한다.
        - Element.removeAttribute(): 요소에서 지정된 이름을 가진 속성을 제거한다.
      - HTML 콘텐츠 조작
      - DOM 요소 조작 메서드
        - document.createElement(tagName): 작성한 tagname의 html 요소를 생성하여 반환
        - Node.appendChild(): 한 노드를 특정 부모 노드의 자식 노드리스트 중 마지막 자식으로 삽입 후 추가된 Node 객체를 반환한다.
        - Node.removeChild(): DOM에서 자식 노드를 제거 후 제거된 노드를 반환.
  - DOM 용어 정리
    - Node: DOM의 기본 구성 단위
    - NodeList: DOM 메서드를 사용해 선택한 Node의 목록
    - Element: DOM 트리에서 HTML 요소를 나타내는 특별한 유형의 Node
    - Parsing: 브라우저가 문자열을 해석하여 DOM Tree로 만드는 과정(구문 분석, 해석)
    - var: ES6 이전에 변수 선언에 사용했던 키워드
      - 함수 스코프(function scope): 함수의 중괄호 내부를 가리키고, 함수 스코프를 갖는 변수는 함수 바깥에서 접근할 수 없다.
      - 호이스팅(hoisting): 변수 선언문이 코드의 최상단으로 끌어올려지는 듯한 현상. var로 선언된 변수는 선언 위치와 관계없이 스코프 최상단에서 선언된 것처럼 동작하며, 할당 전가지는 undefined 값을 갖는다.
        - 허강사님 부가설명: **런타임 이전에** 선언문이 코드의 최상단으로 끌어올려지는 듯한 현상.
        - ```var a = 1;```: ```var a;```라는 변수선언문과 ```a = 1;```라는 변수할당문이 합쳐진 코드.

데이터 타입
- 원시 자료형(primitive type): 값(value) 자체가 변수에 직접 저장되는 자료형. 불변(immutable)이며, 변수 할당 시 값이 복사된다.
  - Number: 정수 또는 실수형 숫자를 표현하는 자료형
    - 문자열과 + 연산시, 숫자가 문자열로 자동 형 변환되어 연결된다.
    - 정수와 실수 구분이 없고, 모든 숫자를 단일 타입으로 처리한다.
  - String: 텍스트 데이터
    - template lieterals(like f-string in python): 내장된 표현식을 허용하는 향상된 문자열 작성 방식 `${ }` 
  - null: 프로그래머가 의도적으로 값이 없음을 표현
  - undefined: 시스템이나 js 엔진이 값이 할당되지 않음을 나타낼 때 사용
  - boolean: 참과 거짓을 나타내는 논리적인 자료형(true, false)
- 참조 자료형(reference type): 데이터가 저장된 메모리의 주소가 변수에 저장되는 자료형. 가변(mutable)이며, 변수 간 할당 시 주소가 복사된다. Objects(object, array, function)

연산자
- 할당 연산자(=)
- 증가 / 감소 연산자(++, --)
- 비교 연산자
- 동등 연산자(==)
  - 두 피연산자가 같은 값으로 평가되는지 비교한 후 불리언 값 반환
  - 암묵적 타입 변환을 통해 타입을 일치시킨 후 값을 비교한다.
  - 두 피연산가 모두 객체일 경우, 메모리의 같은 객체를 바라보는지 판별
- 일치 연산자(===)
  - 두 피연산자의 값과 티입이 모두 같은 경우 참을 반환
  - 엄격한 비교가 이루어지며, 암묵적 타입변환이 발생하지 않는다.
- 논리 연산자
  - and(&&)
  - or(||)
  - not(!)

조건문
- if
- 삼항 연산자": condition ? expression1(true) : expression2(false)

반복문
- while
- for
- for in: object 순회
- for of: iterable 순회

함수
- 참조 자료형에 속하며 모든 함수는 function object


이벤트
- 웹페이지 상에서 무언가 일어났다는 신호 또는 사건
- 웹에서의 모든 상호작용은 이벤트와 함께 한다.
- event object
  - DOM에서 이벤트가 발생하면, 브라우저는 해당 이벤트에 관한 정보를 담은 event object를 자동으로 생성하고 해당 event는 연결된 이벤트 처리기(event handler)에 의해 처리된다.
  - event handler: 특정 이벤트가 발생했을 때 실행되는 (콜백)함수
  - .addEventListener(): 특정 DOM요소에 지정한 이벤트가 발생했을 때 실행할 이벤트 핸들러를 등록하는 메서드


AJAX
- 동기: 프로그램을 순차적으로 실행 - 실행 결과를 예측할 수 있음
- 비동기: 기다리지 않고, 다른 작업을 실행
- 그런데 JS는 싱글 쓰레드이므로 그에 따른 비동기 처리 방식이 필요하다
  - call stack: 함수 호출이 쌓이고, 코드가 동작하는 영역
  - web API: 비동기 작업이 처리되는 곳(브라우저가 담당함)
  - task queue: 처리가 끝난 작업들이 대기하는 곳
  - event loop: call stack이 비어있는 지 확인하고, 비어있으면 task queue에 있는 작업을 옮겨서 마무리한다.
- AJAX: 비동기 통신 기술
- axios: promise 기반의 HTTP 요청을 처리하는 JS 라이브러리
- 비동기 함수를 동기적으로 처리하고 싶을 경우
  - promise 객체: 비동기 작업 결과를 반환(then, catch)
  - async / await를 이용해서 더욱 간결하게 사용히 가능하다


VUE
---

computed(): 계산된 속성을 정의하는 함수
- 미리 계산된 속성을 만들어 템플릿의 표현식을 단순하게 하고, 불필요한 반복 연산을 줄여준다.
- 한번 계산된 값은 캐싱(임시 저장)되어 의존하는 데이터가 바뀌기 전까지 다시 계산하지 않으므로 성능에 매우 유리하다.
- 반환되는 값은 계산된 ref(computed ref)이며, 일반 ref와 유사하게 계산된 결과흫 .value로 참조 가능(템플릿에서는 .value 생략 가능)
- computed 속성은 의존된 반응형 데이터를 자동으로 추적하고 그 데이터가 변경될 때만 재평가한다.
- 의존하는 데이터가 변경되지 않는 한, 해당 computed 속성에 여러번 접근해도 함수를 다시 실행하지 않고 캐시된 결과를 즉시 반환한다.
- 캐시(cache): 데이터나 결과를 일시적으로 저장해두는 임시 저장소

method vs computed():
- 메서드로도 동일한 로직으로 기능을 정의할 수 있다.
- computed 속성은 의존하는 반응형 데이터를 기반으로 그 결과를 캐시하므로 데이터가 변경된 경우에만 재평가하는 반면, 메서드는 렌더링이 발생할 때마다 항상 함수를 실행한다.
- computed
  - 의존하는 데이터에 따라 결과가 바뀌는 계산된 속성을 만들때 유용하다.
  - 동일한 의존성을 가진 여러곳에서 사용할 때 계산 결과를 캐싱하여 중복 계산 방지
- method
  - 단순히 특정 동작을 수행하는 함수를 정의할 때 사용
  - 데이터에 의존하는지 여부와 관계없이 항상 동일한 결과를 반환하는 함수

v-if: 표현식 값의 true/false를 기반으로 요소를 조건부로 렌더링

v-show: 표현식 값의 true/false를 기반으로 요소의 가시성을 전환
- v-if는 DOM 요소를 완전히 제거, v-show는 CSS의 display 속성을 none으로 바꿔 화면에서만 보이지 않게 한다.
- 요소를 자주 보여주고 숨겨야 할 경우, 렌더링 비용이 높은 v-if보다 성능적으로 유리하다. 실행 중 조건이 변경되지 않는 경우에는 v-if를 권장.

v-for: 소스 데이터를 기반으로 요소 또는 템플릿 블록을 반복 렌더링
- alias in expression 형식의 구문을 사용 (변수에 별칭 부여)
- 객체는 key-value 쌍으로 이루어져 있으며 각 값을 조합하여 순회할 수 있다.
- 반드시 내장 특수 속성 key와 함께 사용한다.

watch(): 하나 이상의 반응형 데이터를 감시하고, 감시하는 데이터가 변경되면 콜백 함수를 호출
- 새로운 값을 계산하는 computed와 달리, watch는 데이터가 바뀔 때 특정 행동을 수행한다
- 입력 인자: watch(source(newValue, oldValue))
  - source: watch가 감시하는 대상(반응형 변수, 값을 반환하는 함수 등)
  - callback function: source가 변경될 때 호출되는 콜백 함수
    - newValue: 감시하는 대상이 변화된 값
    - oldValue(optional): 감시하는 대상의 기존 값

Lifecycle Hooks: Vue 컴포넌트가 생성(creation)되고, DOM에 마운트(mounting)되고, 업데이트(updating)되고, 소멸(unmounting)되는 각 생애 주기 단계에서 실행되도록 제공되는 함수
- Creation 단계: 컴포넌트 인스턴스가 생성되고 관찰 가능한 데이터(data, computed, methods) 설정이 완료되는 단계. 아직 DOM 접근은 불가능하다.
  - beforeCreate: 인스턴스가 생성된 직후, 데이터 관찰 및 이벤트 설정이 아직 안된 상태
  - created: 데이터 관찰 및 반응성 시스템이 설정된 후. 인스턴스 데이터에 접근할 수 있으며, 서버에서 데이터를 가져오는 등의 비동기 작업을 하기에 적합하다. 템플릿이나 DOM은 아직 마운트되지 않은 상태이다.
- Mounting 단계: 컴포넌트의 템플릿이 렌더링되어 실제 DOM에 부착되는 단계
  - beforeMount: 템플릿 컴파일이 완료되고 DOM이 렌더링되기 직전
  - mounted: 컴포넌트가 실제 DOM에 완전히 삽입된 후 호출된다. DOM에 직접 접근하거나 서드파티 라이브러리를 통합하기에 가장 적절한 훅이다.
- Updating 단계: 컴포넌트에서 사용되는 반응형 데이터가 변경되어 컴포넌트가 다시 렌더링될 때 발생한다
  - beforeUpdate: 데이터가 변경되어 DOM을 패치하고 다시 렌더링하기 직전에 호출된다. 이 시점에서 새 데이터에 접근할 수 있지만, DOM은 아직 업데이트되지 않은 상태이다.
  - updated: 데이터 변경 후 DOM이 완전히 다시 렌더링되고 패치된 후 호출된다. DOM을 직접 조작하는 작업은 가능하지만, 무한 루프에 빠지지 않도록 주의해야한다.
- Unmounting 단계: 컴포넌트 인스턴스가 DOM에서 제거되는 단계. 메모리 누수를 방지하기 위해 이 단계에서 이벤트 리스너나 타이머 등을 정리해야 한다.
  - beforeUnmount: 컴포넌트 인스턴스가 해제되기 직전에 호출된다. 이벤트 리스너, 구독, 타이머 등을 정리하기에 적합하다.
  - unmounted: 컴포넌트 인스턴스가 완전히 파괴되고 DOM에서 제거된 후 호출된다.

컴포넌트(component): 재사용 가능한 코드블럭
- UI를 독립적이고 재사용 가능한 일부분으로 분할하고 각 부분을 개별적으로 다룰 수 있다.
- 자연스럽게 애플리케이션은 component의 트리 형태로 구성된다.

SFC(Single-File Components): 컴포넌트의 템플릿, 로직 및 스타일을 하나의 파일로 묶어낸 특수한 파일(.vue 파일)
- .vue 파일은 컴포넌트의 HTML, JavaScript, CSS 코드를 모두 담게 되며, 화면 구조를 담당하는 &lt;template&gt;, 로직을 담당하는 &lt;script&gt;, 스타일을 담당하는 &lt;style&gt; 세 부분으로 나뉜다.
- 언어 블록의 작성 순서는 상관 없으나 일반적으로 template -> script -> style 순서로 작성한다.
- 구성요소
  - template 블록: 각 vue 파일은 최상위 template 블록 하나만 포함할 수 있다.
  - script setup 블록: 각 vue 파일은 script setup 블록을 하나만 포함할 수 있다. (일반 script 제외) 
    - 컴포넌트의 setup() 함수로 사용되며 컴포넌트의 각 인스턴스에 대해 실행된다.
    - 변수 및 함수는 동일한 컴포넌트의 템플릿에서 자동으로 사용 가능하다.
  - style scoped 블록: vue 파일에는 여러 style 태그가 포함될 수 있다.
    - scoped가 지정될 경우 CSS는 현재 컴포넌트에만 적용된다.

Vite: Vue 프론트엔드 개발을 위한 빌드 도구
- 개발서버의 시작속도가 매우 빠르고 코드 수정 시 실시간에 가까운 즉각적인 반영을 보여줘, 비교할 수 없이 쾌적한 개발 경험을 제공한다.
- 개발 시에는 파일을 필요할 때만 요청해 속도를 높이고, 배포 시에는 최적화된 파일로 묶어주는(번들링) 역할을 수행한다.

NPM(Node Package Manger); Node.js의 기본 패키지 관리자
- 개발자들이 만든 JS 패키지를 모아놓은 거대한 저장소이자, 그 패키지들을 쉽게 설치하고 관리할 수 있게 해주는 명령어 도구. 프로젝트에 사용된 모든 패키지들의 목록과 버전을 package.json 파일에 기록하여, 다른 사람과 협업하거나 다른 환경에서 작업할 때도 동일한 개발 환경을 쉽게 구축할 수 있도록 도와준다.

모듈(Module): 프로그램을 구성하는 독립적인 코드블록(ex: .js파일)
- 애플리케이션이 점점 더 발전함에 따라 처리해야 하는 JS 모듈의 개수도 극적으로 증가하게 됐고, 성능 병목 현상이 발생하고 모듈 간의 의존성이 깊어지면서 특정한 곳에서 발생한 문제가 어떤 모듈 간의 문제인지 파악하기가 어려워졌다.
- 이러한 복잡하고 깊은 모듈간 의존성 문제를 해결하기 위한 도구 -> Bundler

번들러(Bundler): 여러 모듈과 파일을 하나(혹은 여러개)의 번들로 묶고 최적화하여 사용할 수 있게 만들어주는 도구
- 여러개로 나뉜 JS 모듈 파일들을 하나의 파일로 합침으로써, 브라우저가 수많은 파일을 각각 요청하여 생기는 네트워크 부담을 줄이고, 코드를 브라우저가 이해할 수 있는 형태로 변환해주며 최종적으로 웹사이트의 로딩 속도를 높이고 성능을 최적화하는 역할을 한다.

Vue project 기본 구조
- public directory
  - 주로 다음 정적 파일을 위치시킨다.
    - 소스코드에서 참조되지 않는 코드
    - 항상 같은 이름을 갖는 코드
    - import할 필요 없는 코드
  - 항상 root 절대 경로를 사용하여 참조한다.
    - public/~.png는 /~.png로 참조 가능
- src directory
  - src/assets
    - 프로젝트 내에서 사용되는 정적 자원(이미지, 폰트, 스타일 시트 등)을 관리
    - 컴포넌트 자체에서 참조하는 내부 파일들을 저장
    - 컴포넌트가 아닌 곳에서는 public directory에 위차한 파일을 사용
  - src/components
    - 프로젝트의 주요 소스코드를 포함하는 곳
    - 실제로 작업하게 될 대부분의 소스 코드가 위치
    - 컴포넌트, 스타일, 라우팅 등 프로젝트의 핵심 코드를 관리
  - src/App.vue
    - Vue 앱의 Root 컴포넌트
    - 다른 하위 컴포넌트들을 포함한다
    - 애플리케이션 전체의 레이아웃과 공통적인 요소를 정의
  - src/main.js
    - Vue 애플리케이션을 초기화하고, App.vue를 DOM에 마운트하는 시작점
    - 필요한 라이브러리를 import하고 전역 설정을 수행한다.
- index.html
  - Vue 앱의 기본 HTML 파일
  - main.js에서 App.vue 컴포넌트를 렌더링하고, index.html을 특정 위치에 마운트 시킨다.
  - 필요한 스타일 시트, 스크립트 등의 외부 리소스를 로드 할 수 있음(ex: bootstrap CDN)
- 기타 설정 파일
  - jsconfig.json: 컴파일 옵션, 모듈 시스템 등 설정
  - vite.config.js: Vite 프로젝트 설정 파일, 플러그인, 빌드 옵션, 개발 서버 설정 등
- 패키지 관리
  - package.json
    - 프로젝트에 관한 기본 정보와 패키지 의존성을 정의하는 설계도 파일(메타데이터 파일)
    - 프로젝트가 어떤 패키지를 사용하고, 어떤 스크립트를 실행할 수 있는지 명시
    - npm install시 이를 참조하여 패키지를 설치
  - package-lock.json
    - package.json 을 기반으로 실제 설치된 패키지들의 정확한 버전 정보를 기록하는 파일
    - 실제로 어느 버전의 패키지가 설치되었는지 확정하고 기록
    - 다른 환경에서도 동일한 패키지 구성을 재현 가능하게 한다.
  - node_modules
    - package.json과 package-lock.json에 따라 실제로 설치된 모든 패키지가 저장되는 곳
    - 프로젝트 실행 시 필요한 모든 라이브러리와 코드 파일을 보관
    - 애플리케이션 구동 시 참조되는 실제 데이터 저장소(일반적으로 git으로 추적하지 않음)

Virtual DOM: 가상의 DOM을 메모리에 저장하고 실제 DOM과 동기화하는 프로그래밍 개념
- Vue에서는 직접적으로 DOM에 접근하는 것을 권장하지 않고 있다. (JS에서의 DOM 접근 관련 메서드 사용 금지)
- Vue의 ref()와 Lifecycle Hooks 함수를 사용해 간접적으로 접근하여 조작할 것을 권고 - 성능과 코드의 예측 가능성을 극대화하기 위해서
- 이것을 위해 사용하는 것이 가상 DOM이다.
- 실제 DOM의 모습을 그대로 복사한 메모리상에만 존재하는 가상 설계도로, 데이터가 변경되면 Vue는 실제 DOM을 바로 건드리지 않고 이 가상 설계도 위에서 변경 사항을 미리 시뮬레이션하고 차이점을 계산하고 계산된 최소 변경 사항만 실제 DOM에 딱 한번만 적용하여 불필요한 렌더링을 줄이고 성능을 향상시킨다.