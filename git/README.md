- GUI(Graphing User Interface)
: **그래픽**을 통해 사용자와 컴퓨터가 상호 작용하는 방식

- CLI(Command Line Interface)
: **명령어**를 통해 사용자와 컴퓨터가 상호 작용하는 방식

- CLI 기초 문법
  - .: 현재 디렉토리
  - ..: 상위 디렉토리(부모 폴더)
  - touch: 파일 생성
  - mkdir: 디렉토리 생성
  - ls: 현재 작업중인 디렉토리 내 모든 디렉토리/파일 목록 호출(list)
  - cd: 현재 작업중인 디렉토리를 변경
  - start: 디렉토리 내 파일을 실행 혹은 디렉토리 열기
  - rm: 파일 삭제
  - rm -r: 디렉토리 삭제
  - pwd: 현재 작업중인 디렉토리의 절대 경로를 출력

- git: **분산** 버전 관리 시스템

- git의 영역
  - working directory
  - staging area
  - repository

- git command
  - git init: .git 폴더 생성
  - git add: 변경내역이 있는 파일을 staging area로 보내기
  - git commit: staging area에 있는 변경 내역에 그 내용을 메모하기
  - git push: commit이 완료된 내용을 repository로
  - git clone: repository에 있는 파일을 그대로 로컬 저장소로 복제(.git 폴더 포함, **git init할 필요 없음!**)
  - git pull: repository와 변경내역만을 받아오기

- gitignore: 디렉토리 내에 있는 파일 중 repository로 보내고 싶지 않은 파일의 목록을 작성

- revert & reset
  - git revert: 특정 commit을 없었던 일로 만드는 작업 <br> ```git revert <commit id>```
  - 단일 commit을 실행 취소, 그 후 그 결과를 새로운 commit으로 추가
  - commit 자체를 삭제하는 것이 아니라, 그 commit을 취소하는 새로운 commit을 추가함으로써 기록의 손실을 방지하며 기록의 무결성과 협업의 신뢰성을 높인다.
  - 추가 명령어(참고만 할것)
    - 공백을 사용하여 여러개의 commit을 한번에 실행 취소 <br> ```git revert <commit id_1> <commit id_2> ...```
    - '..'을 사용해 범위를 지정하여 다수의 commit을 한번에 실행 취소(가급적 사용할 일이 없게 할것) <br> ```git revert <commit id_1>..<commit id_n>```
    - commit 메시지 작성을 위한 편집기를 열지 않기 (자동 commit 진행) <br> ```git revert --no-edit <commit id>```


※ git rm --cached와 git restore --staged의 차이? (교안과 다소 차이 있음)

git branch: 여러 갈래로 작업 공간을 나누어 독립적으로 작업할 수 있도록 도와주는 git의 도구
  - 장점
    - 독립된 개발환경을 형성함으로써 원본에 대한 안전성 확보
    - 하나의 작업은 하나의 브랜치로 나누어 진행되므로 체계적으로 협업과 개발이 가능
    - 손쉽게 브랜치를 생성하고 브랜치 사이를 이동하는 것이 가능
  - 브랜치를 사용한 에러 해결 과정
    1. 브랜치를 통해 별도의 작업 공간 생성
    2. 브랜치에서 에러가 발생한 버전을 이전 버전으로 되돌리거나 삭제
    3. 새로 생성한 브랜치는 master 브랜치와 완전하게 독립되어 있으므로 영향을 끼칠 수 없다.
    4. 에러가 해결된 후 master 브랜치에 이를 반영 
  - 명령어
    - git branch
      - ```git branch```: 브랜치 목록 확인
      - ```git branch -r```: 원격 저장소의 브랜치 목록 확인
      - ```git branch branch_name```: 새로운 브랜치 생성
      - ```git branch -d branch_name```: 브랜치 삭제(병합된 브랜치만 삭제 가능)
      - ```git branch -D branch_name```: 브랜치 삭제(강제 삭제)
    - git switch
      - ```git switch other_branch_name```: 다른 브랜치로 전환
      - ```git switch -c other_branch_name```: 새 브랜치 생성 후 전환
      - ```git switch -c other_branch_name commit_id```: 특정 커밋에서 새 브랜치 생성 후 전환
  - HEAD: 현재 브랜치나 커밋이 가리키는 포인터
  - ```git merge merge_branch_name```: 두 브랜치를 하나로 병합(수신 브랜치의 상태를 병합 브랜치의 상태로)
    - 주의사항
      - 수신 브랜치 확인: HEAD가 올바른 수신 브랜치를 가리키는지 확인, 병합 진행위치는 반드시 수신 브랜치에서 진행되어야 한다.
      - 최선 커밋 상태 확인: 수신 브랜치와 병합 브랜치 모두 최신 상태인지 확인해야 한다.
    - 종류
      - fast-forward merge: 브랜치를 실제로 병합하는 대신 현재 브랜치 상태를 대상 브랜치 상태로 이동시키는 작업(빨리감기)
      - 3-way merge: 병합하는 각 브랜치의 커밋 2개와 공통 조상 커밋 하나를 사용하여 병합하는 작업
        - vim환경에서 :qw 입력하면 탈출
    - merge confilct: 병합하려는 두 브랜치가 '동일한 파일의 동일한 부분'에서 변경된 후 병합 시 충돌이 발생하는 것
  Git workflow: 원격 저장소를 활용해 다른 사용자와 협업하는 방법
  - Feature branch workflow(shared repository model): 각 사용자가 원격저장소의 소유권을 공유받는 방식
    - 중앙 원본 저장소(origin)는 하나, 기능 개발은 별도의 브랜치에서
    - 모든 팀원이 하나의 중앙 원본 저장소를 공유
    - master(main) 브랜치는 항상 안정적이고 배포 가능한 상태로 유지된다.
    - 새로운 기능 개발이나 버그 수정은 반드시 'feature/~', 'fix/~'와 같이 별도의 브랜치를 생성하여 진행
    - 작업이 완료되면, 중앙 저장소에 브랜치를 푸시하고 풀 리퀘스트(pull request, PR)를 통해 코드 리뷰를 거친 뒤 master 브랜치에 병합
      - PR: 내가 별도 브랜치에서 작업한 새로운 내용을 원본 브랜치에 합병해달라고 공식적으로 요청하는 기능. 단순한 코드 합치기 요청이 아닌 협업을 위한 핵심 소통 도구
        - 코드를 합치기 전, 동료나 프로젝트 관리자가 변경된 내용을 검토하고 피드백을 줄 수 있는 공식적인 장을 마련하는 것
    - 목적: master 브랜치의 안정성을 확보하고, 여러 기능 개발이 서로 충돌 없이 동시에 진행될 수 있도록 하기 위함
    - 사용 시점: 신뢰할 수 있는 팀원들이 하나의 프로젝트를 함께 개발할 때 가장 표준적으로 사용되는 방식
    - git flow: 프로젝트를 운영할 때 원활한 협업과 체계적인 버전 관리를 위해 사용하는 브랜치 관리전략 중 하나
      - 핵심 아이디어: main, develop, feature, release, hotfix라는 5가지 종류의 브랜치를 각자의 명확한 역할에 따라 운영하는 방식
      - 이 전략이 항상 완벽한 정답은 아니나, 충돌을 최소화하고 배포 과정을 안정적으로 관리하는 데 큰 도움이 될 수 있다.
      - 메인 브랜치
        - master: 제품 그 자체 - 실제 프로덕션에 배포되는 가장 안정적인 최신 버전의 코드를 관리.
          - 이 브랜치에는 절대 직접 커밋하지 않는다.
          - 오직 release 브랜치 또는 hotfix 브랜치의 내용만 병합된다.
          - master 브랜치의 모든 커밋은 항상 배포 가능한 상태임을 보장해야 한다.
          - 각 커밋은 v1.0, v1.1과 같은 버전 태그로 관리하는 것이 좋다.
        - develop: 다음 배포를 위한 개발 가지 - 다음 릴리즈 버전을 개발하기 위한 모든 기능들이 통합되는 브랜치.
          - master 브랜치에서 최초로 생성되며, master와는 독립적으로 개발이 진행
          - 이 브랜치에도 직접 커밋하지 않는 것을 원칙으로 한다
          - 모든 feature 브랜치들이 개발 완료 후 develop으로 병합된다
          - 배포할 시점이 되면, 이 브랜치에서 release 브랜치가 분기된다
      - 보조 브랜치
        - feature: 기능 개발 작업실 - 하나의 특정 기능을 개발하기 위한 브랜치
          - 항상 develop 브랜치에서 분기함
          - 브랜치 이름에는 feature/login, feature/cart처럼 기능을 명시하는 것이 좋다.
          - 개발이 완료되면 다시 develop 브랜치로 병합한다.
          - master나 release 브랜치와는 절대 직접 상호작용하지 않는다.
        - release: 배포를 위한 최종 점검 - 이전 버전 배포를 준비하기 위한 브랜치. 새로운 기능 개발을 멈추고, 배포 전 최종 테스트와 버그 수정, 버전 번호 업데이트 등만 수행한다.
          - develop 브랜치에서 분기
          - 배포 준비가 완료되면, master 브랜치로 병합하여 배포한다.
          - release 브랜치에서 수정한 버그 내용이 develop 브랜치에도 반영될 수 있도록, **반드시** develop 브랜치에도 다시 병합해야 한다.
        - hotfix: 긴급, 프로덕션 버그 수정 - 이미 배포된 master 브랜치에서 발생한 긴급한 버그를 즉시 수정하기 위한 브랜치
          - develop이나 feature를 기다릴 수 없으므로, 항상 master에서 브랜치에서 직접 분기
          - 버그 수정이 완료되면, 즉시 master 브랜치로 병합하여 재배포
          - 이 버그 수정 내용은 **반드시** develop 브랜치에도 병합하여 다음 릴리즈 버전에 해당 버그가 다시 포함되는 것을 방지해야 한다.
  - Forking workflow(fork & pull model): 각 사용자가 소유권이 없는 원격저장소를 복제하는 방식
    - Fork: 다른 사용자의 원격 저장소를 자신의 계정으로 복사하는 것
    - 중앙 원본 저장소에 직접 푸시 할 수 없다.
    - 개발자는 먼저 중앙 저장소를 내 개인 계정으로 그대로 fork하여 완전히 독립적인 나만의 원격 저장소(origin)를 만든다.
    - 모든 작업은 내 개인 저장소에서 자유롭게 이루어진다.
    - 작업이 완료되면, 내 저장소에서 중앙 원본 저장소로 PR을 보내 병합을 제안
    - 원본 저장소의 관리자가 이 제안을 검토하고 승인해야만 원본에 병합된다.
    - 목적: 원본 프로젝트의 코드 품질과 안정성을 최고 수준으로 유지하고, 외부 기여자의 코드를 안전하게 검토하기 위함
    - 사용 시점: 오픈 소스 프로젝트처럼, 핵심 관리자 그룹 외에 신뢰할 수 없는 다수의 외부 기여자가 프로젝트에 참여할 때 사용된다.